(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * AJAX Save This Component (v0.1): ajax_save.js
 *   -- simple form sumbit via ajax.
 *
 *   Dependencies:  Bootstrap + JQuery + spinner
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './spinner');
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.ajax_save',
        widgetClass = 'bse-ajax-save',
        classes = widgetClass.buildNamesMap(['this', 'it']),
        selectors = widgetClass.buildNamesMap(['this', 'it'], '.');

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            action: false,
            method: 'POST',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null   // called when range_input is changed, before saving - return false to prevent default action
        },

        // Configure the widget controls (edit icon and form elements)
        _configureControls : function() {
            this.form = this.element;
            this.form.spinner( { disable_on_spin: true } );
            this.spinner = this.form.spinner('instance');
            this.options.action = this.options.action || this.form.attr('action');
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;

            this.element.submit( function (event) {
                event.preventDefault();
                self._saveForm(event);
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            console.log("Create ", widgetName, " instance for", this.element);
            this._getDataOptions();
            this._ajaxConfig();
            this._configureControls();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log("Destroy: ", this.element);
            this.element.off('submit');
            // TO DO: put form back from whence it came?
        },

        _saveForm: function ( event ) {
            // allow user to augment or override default save logic
            var go = this._trigger( 'saveForm', event, { form_data: this.form.serialize() });
            if ( go && this.options.action ) {
                this._ajaxSubmitForm(this.options);
            }
        }
    });

    $(selectors[widgetClass]).ajax_save();

})( jQuery, window, document );


},{"./jquery-ui-widget":5,"./jquery-ui-widget-extensions":4,"./spinner":8,"./util":9}],2:[function(require,module,exports){
/**
 * Table Column Collapse (v0.1): col_collapse.js
 *   -- Collapse / Expand table columns by clicking on a cc-control.
 *   -- Demo: https://jsfiddle.net/powderflask/gd7ct85q/
 *   Use data-controls attribute on control to specify class of cc-target elements to collapse.
 *   Use data-controls='all' to control all cc-target elements
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.col_collapse',
        widgetClass = 'bse-col-collapse',
        classes = widgetClass.buildNamesMap(['collapsed', 'icon']),
        selectors = widgetClass.buildNamesMap(['collapsed', 'icon', 'add', 'controlAll', 'control', 'controlLabel'], '.'),

        markup = {
            expand_icon: ['<span>', {'class': classes.icon, 'aria-hidden': 'true'}],
        };

        // helpers
        expand = function(el){
            el.removeClass(classes.collapsed);
        };
        collapse = function(el){
            el.addClass(classes.collapsed);
        };
        toggleCollapsed = function(el) {
            el.toggleClass(classes.collapsed);
        };
        isCollapsed = function(el) {
            return el.hasClass(classes.collapsed);
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            control_title: 'Expand/Collapse Column',
            controlAll_title: 'Expand/Collapse All',
            controlAll_labels: {true: 'Expand All', false: 'Collapse All'},  // null or false to leave default
            icon_class: 'glyphicon glyphicon-resize-full bse-rotate-45',

            // event callbacks
            collapsed: null,
            expanded: null
        },

        // Configure and return the widget controls
        _configureControls : function() {
            var expand_icon = $.apply(this, markup.expand_icon).addClass(this.options.icon_class),
                col_controls = this.element.find(selectors.control),
                global_controls = this.element.find(selectors.controlAll);

            col_controls.append(expand_icon.clone())
                        .attr('title', this.options.control_title);
            global_controls.prepend(expand_icon.clone())
                           .attr('title', this.options.controlAll_title);
            collapse(global_controls);  // Assume initial state for global control is Expand All?
            global_controls.data('controls', col_controls);
            return {
                col : col_controls,
                global : global_controls
            };
        },

        // Configure the collapse targets for each control -- i.e., td elements in the same column
        _configureTargets : function(col_controls) {
            var table = this.element.is('table')?this.element:this.element.find('table')[0]
            table.addClass(widgetClass);
            // For each control, get all targets from its table column ( http://jsfiddle.net/8XSLF/ )
            $.each(col_controls, function(idx, val) {
                var control = $(this),
                    colNumber = control.parent("tr").children().index(control),
                    rows = table.find('> tbody > tr'),
                    targets = rows.find('td:nth-child(' + (colNumber + 1) + ')').add(control);
                if ( isCollapsed(control) ) {
                    collapse(targets);
                }
                control.data('targets', targets);
            });
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;
            this.controls.col.click( function(event) {
                self.toggleTargets($(this), event);
            });
            this.controls.global.click( function(event) {
                var control = $(this);
                expandAll = isCollapsed(control);
                $.each(self.controls.col, function() {
                    expandAll ? self.expandTargets($(this), event):self.collapseTargets($(this), event);
                });

                // optionally, change control's label
                toggleCollapsed(control);
                if (self.options.controlAll_labels) {
                    var label = control.find(selectors.controlLabel);
                    label.html(self.options.controlAll_labels[isCollapsed(control)]);
                }

            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log('Create ', widgetName, 'instance for', this.element);
            this._getDataOptions(); // if widget recognizes data-* options in markup
            this.controls = this._configureControls();
            this._configureTargets(this.controls.col);
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log('Destroy:', this);
            $(selectors.collapsed).removeClass(classes.collapsed);
            $(selectors.icon).remove();
            this.controls.col.attr('title', '').off('click');
            this.controls.global.attr('title', '').off('click');
            this.controls.col.data('targets', null);
            this.controls.global.data('controls', null);
        },

        // Public methods
        expandTargets : function(control, event) {
            var targets = control.data('targets');
            expand(targets);
            this._trigger( 'expanded', event, { control:control, targets:targets });
        },
        collapseTargets : function(control, event) {
            var targets = control.data('targets');
            collapse(targets);
            this._trigger( 'collapsed', event, { control:control, targets:targets });
        },
        toggleTargets : function(control, event) {
            isCollapsed(control) ? this.expandTargets(control, event) : this.collapseTargets(control, event);
        }
    });

    $(selectors.add).col_collapse();

})( jQuery, window, document );
},{"./jquery-ui-widget":5,"./jquery-ui-widget-extensions":4,"./util":9}],3:[function(require,module,exports){
/**
 * Edit This Component (v0.1): edit-this.js
 *   -- toggle display value with edit form for the value
 *   -- optionally, AJAX save edited form.
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.edit_this',
        widgetClass = 'bse-edit-this',
        classes = widgetClass.buildNamesMap(['icon', 'content']),
        selectors = widgetClass.buildNamesMap(['content'], '.'),

        markup = {
            edit_icon: ['<span>', {'class': classes.icon, 'aria-hidden': 'true'}]
         };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            action: false,
            method: 'POST',
            icon_class: 'glyphicon glyphicon-edit',
            icon_title: 'Edit this',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null,   // called when range_input is changed, before saving - return false to prevent default action
            showForm: null,   // called when form is shown
            hideForm: null    // called when form is hidden
        },

        // Update the content area from the current form value.
        _updateContent : function() {
            this.content.html(this.form_controls.val());
            this.content.append(this.edit_icon);
        },

        // Configure the widget controls (edit icon and form elements)
        _configureControls : function() {
            this.content = this.element.find(selectors.content);
            this.edit_icon = $.apply(this, markup.edit_icon)
                              .addClass(this.options.icon_class)
                              .attr('title', this.options.icon_title);
            this.content.append(this.edit_icon);

            // And the form...
            var form_id = this.element.data('form_id');
            this.form = $('#'+form_id);
            // Configure optional Ajax save with callback to hide the form on successful requests.
            this.form.ajax_save( $.extend(this.options, {ajax_success:this.hideForm.bind(this)}) );

            // ... move form to edit-this panel ...
            this.form_controls = this.form.find( ':input' );
            this.element.append(this.form.hide());
        },

        // is the target element part of the widget element?
        _contains : function(target) {
            return target.closest(this.element).length > 0;
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;

            this.content.on('click', function (event) {
                event.preventDefault();
                self.showForm(event);
                self.form_controls[0].focus();
            });
            // hide form on clicks that are not within the element.
            $('body').click(function(event) {
                if (!self._contains($(event.target))) {
                    self.hideForm(event);
                }
            });

            this.form.on('change', function (event) {
                event.preventDefault();
                self._updateContent();
                self.form.submit();
                self.hideForm(event);
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this._configureControls();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log("Destroy: ", this.element);
            this.edit_icon.remove();
            this.hideForm();
            this.content.off('click');
            // TO DO: put form back from whence it came?
        },

        // Public methods
        showForm : function(event) {
            this.content.hide();
            this.form.show();
            this._trigger( 'showForm', event);
        },
        hideForm : function(event) {
            this.form.hide();
            this.content.show();
            this._trigger( 'hideForm', event);
        },
        isFormVisible: function() {
            return this.form.is(":visible");
        },
        toggleForm : function(event) {
            this.isFormVisible() ? this.showForm(event) : this.hideForm(event);
        }
    });

    $(selectors[widgetClass]).edit_this();

})( jQuery, window, document );


},{"./jquery-ui-widget":5,"./jquery-ui-widget-extensions":4,"./util":9}],4:[function(require,module,exports){
/**
 * Extensions for jQuery UI Widget Factory
 *    - _getDataOptions:  load options from data-option attributes in element's markup
 *    - _ajaxConfig
 *
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require( './jquery-ui-widget');
require( './util');

(function( $, window, document, undefined ) {

    const ajax_error_template =
        '<div class="alert alert-warning alert-dismissible" role="alert">' +
            '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' +
                '<span aria-hidden="true">&times;</span>' +
            '</button>' +
            'Oops! We encountered an error processing your request: {textStatus}' +
            '<br>Refresh page and try again?' +
        '</div>';

    var WidgetExtensionsMixin = {
        // Load any data- attribute options from the element's tag
        _getDataOptions : function() {
            var data_opts = this.element.data();
            opts = this.options;
            Object.keys(data_opts).forEach(function(key) {
                if (key in opts) {
                    opts[key] = data_opts[key];
                }
            });
        },

       /*
         * Standardized jQuery.ajax calls with default behaviours + triggers for BSE widgets
         *   E.g., this.ajax_submit_form({ optional_ajax_settings_or_overrides })
         *   Adds an optional callback and trigger for each local Ajax Event.
         */

        // Add ajax trigger events to this widget's options
        _ajaxConfig : function() {
             // Events triggered by ajax calls, used to extend widget options
            const ajax_event_options= {
                ajax_beforeSend: null,
                ajax_success: null,
                ajax_error: null,
                ajax_complete: null
            };
            this.options = $.extend({}, ajax_event_options, this.options);
        },


        // Submit this.form by ajax, with an optional this.spinner to display while loading
        _ajaxSubmitForm : function(settings) {
            console.assert(this.form, "BSE ajax_submit_form Error: this.form must be set on widget.");
            var form_data = this.form.serialize() || "",
                extra_data = settings.data || "",
                action = settings.action || form.attr('action'),
                method = settings.method || form.attr('method') || 'POST';
            console.assert(action, "BSE ajax_submit_form Error: a form action option must be supplied.");

            var self = this;
            args = {
                url: action,
                method: method,
                data: form_data + extra_data,

                // Ajax events
                beforeSend: function () {
                    if (self.spinner) self.spinner.show();
                    if (settings.beforeSend) settings.beforeSend();
                    self._trigger('ajax_beforeSend', null, {form_data: form_data, args: arguments});
                },
                success: function (json, textStatus, xhr) {
                    if (json.message) self.form.before(json.message);
                    if (settings.success) settings.success();
                    self._trigger('ajax_success', null, {args: arguments});
                },
                error: function (xhr, textStatus, errorThrown) {
                    self.form.after($(ajax_error_template.formatUnicorn({textStatus: textStatus})));
                    console.log(xhr.status + ": " + xhr.responseText);
                    console.log(errorThrown);
                    if (settings.error) settings.error();
                    self._trigger('ajax_error', null, {args: arguments});
                },
                complete: function (xhr, textStatus) {
                    if (self.spinner) self.spinner.hide();
                    if (settings.complete) settings.complete();
                    self._trigger('ajax_complete', null, {args: arguments});
                }
            };

            $.ajax(args);

        }
    };

    if ('Widget' in $) {
        Object.assign($.Widget.prototype, WidgetExtensionsMixin);
    }
})(jQuery, window, document);

},{"./jquery-ui-widget":5,"./util":9}],5:[function(require,module,exports){
/*! jQuery UI - v1.12.1 - 2018-06-05
* http://jqueryui.com
* Includes: widget.js, position.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;




}));
},{}],6:[function(require,module,exports){
/**
 * Bootstrap Extras (v0.1): main.js
 *   -- Collate all component scripts via Broswerify https://www.npmjs.com/package/browserify
 *
 *   External Dependencies:  Bootstrap 3 + JQuery 2+
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require('./ajax_save');
require('./edit-this');
require('./col_collapse');
require('./progress_report');
require('./spinner');

},{"./ajax_save":1,"./col_collapse":2,"./edit-this":3,"./progress_report":7,"./spinner":8}],7:[function(require,module,exports){
/**
 * Progress Report Component (v0.1): progress_report.js
 *   -- a Bootstrap Progress Bar with an interactive range input
 *   -- AJAX save selected value using standard HMTL form.
 *
 *   Dependencies:  Bootstrap + JQuery + spinner
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './spinner');
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.progress_report',
        widgetClass = 'bse-progress-report',
        classes = widgetClass.buildNamesMap(['panel', 'form', 'value']),
        selectors = widgetClass.buildNamesMap(['wrap'], '.'),

        markup = {
            panel : ['<div>', {'class': classes.panel}],
            form : ['<form>', {'class': classes.form}],
            input : ['<input>', {type:'range', 'class': widgetClass, name:classes.value, required:''}]
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            min: 0,
            max: 100,
            action: false,
            method: 'POST',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null   // called when range_input is changed, before saving - return false to prevent default action
        },

        // Template node for the widget
        _template : function() {
            this.progress = this.element.clone();
            this.progress_bar = this.progress.find('.progress-bar');
            this.value = this.progress_bar.attr('aria-valuenow');
            this.range_input = $.apply(this, markup.input);  // $(...markup.input)
            this.form = $.apply(this, markup.form).append(this.range_input);
            this.panel = $.apply(this, markup.panel).append(this.progress).append(this.form);

            // Configure optional Ajax save with callback to hide form on successful requests.
            this.form.ajax_save( $.extend(this.options, {ajax_success:this.form.hide.bind(this.form)}) );
            this.range_input.attr('min', this.options.min).attr('max', this.options.max);
            this.range_input.val(this.value);

            return this.panel;
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this,
                spinner = self.form.spinner('instance');  // ouch - tight coupling to ajax-save here.

            this.range_input.on('input', function(event) {
                self.value = self.range_input.val() || 0;
                self.progress_bar.text(self.value + '% Complete');
                self.progress_bar.css( 'width', self.value+'%');
                spinner.position( {top: '-1em', left:(self.value-1)+'%'} );
            });

            this.progress.on('click', function (event) {
                event.preventDefault();
                self.form.show();
                self.range_input.focus();
                self.range_input.blur(function (event) {
                   self.form.hide();
                });
            });

            this.form.on('change', function (event) {
                event.preventDefault();
                self.form.submit();
                self.form.hide();
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this.element.after(this._template());
            this.element.hide();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            console.log("Destroy: ", this.panel);
            this.panel.remove();
            this.element.show();
        }
    });

    $(selectors.wrap).progress_report();

})( jQuery, window, document );


},{"./jquery-ui-widget":5,"./jquery-ui-widget-extensions":4,"./spinner":8,"./util":9}],8:[function(require,module,exports){
/**
 * AJAX Loading Spinner (v0.1): spinner.js
 *   -- a JQuery plugin spinner to signal asyn request in-progress
 *   -- show / hide spinner can optionally control enable/disable widget's element
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.spinner',
        widgetClass = 'bse-spinner',
        selectors = {
            'append' : '.'+widgetClass+'-append'
        },
        markup = {
            spinner: ['<span>', {'class': widgetClass}]
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            spin_text: 'Saving...',  // title and accessibility text for spinner
            disable_on_spin: false,  // set to true to disable all :inputs in the parent element when spinner shows

            // event callbacks
            hidden: null,   // triggers when spinner is hidden
            shown: null     // triggers when spinner is shown
        },

        // Template node for the widget
        _template : function() {
            return $.apply(this, markup.spinner).hide().html(this.options.spin_text);
        },

        _getDisableTargets : function() {
            if (!this.options.disable_on_spin)
                return $();

            var form = this.element.closest('form');
            if (form.length > 0)  // Disable all form inputs if spinner element is in a form
                return form.find(':input');
            else                  // or all inputs contained in the spinner element otherwise.
                return this.element.extend( this.element.find(':input') );
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log('Appending', widgetName, 'instance to', this.element, ':');
            this._getDataOptions();
            this.spinner = this._template();
            // console.log(this.spinner);
            this.element.append(this.spinner);
            this.original_title = this.element.attr('title') || "";
            this.targets = this._getDisableTargets();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log('Destroy:', this);
            this.spinner.remove();
        },

        // Position the spinner from its relative location
        position: function(relative_pos) {
            this.spinner.css(relative_pos);
        },

        // Show, Hide, and Toggle the spinner.
        hide: function(event) {
            this.element.attr('title', this.original_title);
            this.targets.prop('disabled', false);
            this.spinner.hide();
            this._trigger( 'hidden' , event);
        },
        show: function(event) {
            this.spinner.show();
            this.element.attr('title', this.options.spin_text);
            this.targets.prop('disabled', true);
            this._trigger( 'shown' , event);
        },
        toggle : function(event) {
            if (this.spinner.is(":visible")) this.hide(event); else this.show(event);
        }
    });

    $(selectors.append).spinner();

})( jQuery, window, document );
},{"./jquery-ui-widget":5,"./jquery-ui-widget-extensions":4}],9:[function(require,module,exports){
/**
 * Bootstrap Extra Utilities
 *   ... or, things you can't believe are not included out-of-the-box with JS
 *
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

// https://stackoverflow.com/a/18234317/1993525
String.prototype.formatUnicorn = String.prototype.formatUnicorn ||
function () {
    "use strict";
    var str = this.toString();
    if (arguments.length) {
        var t = typeof arguments[0];
        var key;
        var args = ("string" === t || "number" === t) ?
            Array.prototype.slice.call(arguments)
            : arguments[0];

        for (key in args) {
            str = str.replace(new RegExp("\\{" + key + "\\}", "gi"), args[key]);
        }
    }

    return str;
};

String.prototype.asTemplate = String.prototype.asTemplate ||
function () {
    "use strict";
    var template = this.toString();

    return function(args) {
        return template.formatUnicorn(args);
    };
};

// Return an object with property, el:name, for each el in extensions, where name = pre + this + sep + el
String.prototype.buildNamesMap = String.prototype.buildNamesMap ||
function (extentions, pre, sep) {
  pre = pre || '';
  sep = sep || '-';
  var base = this;
  function build(obj, key) {
    obj[key] = pre+base+sep+key;
    return obj;
  }
  var map = extentions.reduce(build, {});
  map[base] = pre+base;
  return map;
};


// replace jQuery.ajax with a function that mocks a successful AJAX response.
// call bseAjaxMockSuccess() before testing.  To Do:  use proper testing framework (jest) + http://sinonjs.org/#testing-ajax
bseAjaxMockSuccess = function() {
    $.ajax = function(args) {
        args.beforeSend();
        console.log("call ajax:", args);
        setTimeout(function() {
            args.success({message : 'Mock AJAX call (success).'});
        }, 3000);
        setTimeout(function() {
            args.complete();
        }, 3000);
    }
};
},{}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL2FqYXhfc2F2ZS5qcyIsInNjcmlwdHMvY29sX2NvbGxhcHNlLmpzIiwic2NyaXB0cy9lZGl0LXRoaXMuanMiLCJzY3JpcHRzL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucy5qcyIsInNjcmlwdHMvanF1ZXJ5LXVpLXdpZGdldC5qcyIsInNjcmlwdHMvbWFpbi5qcyIsInNjcmlwdHMvcHJvZ3Jlc3NfcmVwb3J0LmpzIiwic2NyaXB0cy9zcGlubmVyLmpzIiwic2NyaXB0cy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogQUpBWCBTYXZlIFRoaXMgQ29tcG9uZW50ICh2MC4xKTogYWpheF9zYXZlLmpzXG4gKiAgIC0tIHNpbXBsZSBmb3JtIHN1bWJpdCB2aWEgYWpheC5cbiAqXG4gKiAgIERlcGVuZGVuY2llczogIEJvb3RzdHJhcCArIEpRdWVyeSArIHNwaW5uZXJcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cbnJlcXVpcmUoICcuL3NwaW5uZXInKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSggJy4vdXRpbCcgKTtcblxuOyhmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4gICAgdmFyIHdpZGdldE5hbWUgPSAnYnNlLmFqYXhfc2F2ZScsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1hamF4LXNhdmUnLFxuICAgICAgICBjbGFzc2VzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ3RoaXMnLCAnaXQnXSksXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWyd0aGlzJywgJ2l0J10sICcuJyk7XG5cbiAgICAkLndpZGdldCggd2lkZ2V0TmFtZSwge1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gYmUgdXNlZCBhcyBkZWZhdWx0c1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBhY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrcyAoYWpheCBldmVudCBjYWxsYmFja3MgYWxzbyB0cmlnZ2VyKVxuICAgICAgICAgICAgc2F2ZUZvcm06IG51bGwgICAvLyBjYWxsZWQgd2hlbiByYW5nZV9pbnB1dCBpcyBjaGFuZ2VkLCBiZWZvcmUgc2F2aW5nIC0gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb25maWd1cmUgdGhlIHdpZGdldCBjb250cm9scyAoZWRpdCBpY29uIGFuZCBmb3JtIGVsZW1lbnRzKVxuICAgICAgICBfY29uZmlndXJlQ29udHJvbHMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5zcGlubmVyKCB7IGRpc2FibGVfb25fc3BpbjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIgPSB0aGlzLmZvcm0uc3Bpbm5lcignaW5zdGFuY2UnKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hY3Rpb24gPSB0aGlzLm9wdGlvbnMuYWN0aW9uIHx8IHRoaXMuZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmVudHMgaGFuZGxlZCBieSB0aGlzIHdpZGdldFxuICAgICAgICBfY29uZmlndXJlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3VibWl0KCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3NhdmVGb3JtKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlIFwiLCB3aWRnZXROYW1lLCBcIiBpbnN0YW5jZSBmb3JcIiwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2dldERhdGFPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9hamF4Q29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmVDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlc3Ryb3kgcGx1Z2luIGluc3RhbmNlICBhbmQgY2xlYW4gdXAgbW9kaWZpY2F0aW9ucyB0aGUgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveTogXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub2ZmKCdzdWJtaXQnKTtcbiAgICAgICAgICAgIC8vIFRPIERPOiBwdXQgZm9ybSBiYWNrIGZyb20gd2hlbmNlIGl0IGNhbWU/XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NhdmVGb3JtOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgLy8gYWxsb3cgdXNlciB0byBhdWdtZW50IG9yIG92ZXJyaWRlIGRlZmF1bHQgc2F2ZSBsb2dpY1xuICAgICAgICAgICAgdmFyIGdvID0gdGhpcy5fdHJpZ2dlciggJ3NhdmVGb3JtJywgZXZlbnQsIHsgZm9ybV9kYXRhOiB0aGlzLmZvcm0uc2VyaWFsaXplKCkgfSk7XG4gICAgICAgICAgICBpZiAoIGdvICYmIHRoaXMub3B0aW9ucy5hY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWpheFN1Ym1pdEZvcm0odGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJChzZWxlY3RvcnNbd2lkZ2V0Q2xhc3NdKS5hamF4X3NhdmUoKTtcblxufSkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXG4iLCIvKipcbiAqIFRhYmxlIENvbHVtbiBDb2xsYXBzZSAodjAuMSk6IGNvbF9jb2xsYXBzZS5qc1xuICogICAtLSBDb2xsYXBzZSAvIEV4cGFuZCB0YWJsZSBjb2x1bW5zIGJ5IGNsaWNraW5nIG9uIGEgY2MtY29udHJvbC5cbiAqICAgLS0gRGVtbzogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcG93ZGVyZmxhc2svZ2Q3Y3Q4NXEvXG4gKiAgIFVzZSBkYXRhLWNvbnRyb2xzIGF0dHJpYnV0ZSBvbiBjb250cm9sIHRvIHNwZWNpZnkgY2xhc3Mgb2YgY2MtdGFyZ2V0IGVsZW1lbnRzIHRvIGNvbGxhcHNlLlxuICogICBVc2UgZGF0YS1jb250cm9scz0nYWxsJyB0byBjb250cm9sIGFsbCBjYy10YXJnZXQgZWxlbWVudHNcbiAqXG4gKiAgIERlcGVuZGVuY2llczogIEJvb3RzdHJhcCArIEpRdWVyeVxuICogICBNSVQgT3Blbi1zb3VyY2UgTGljZW5zZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bvd2RlcmZsYXNrL2Jvb3RzdHJhcF9leHRyYXMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldCcpO1xucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCAnLi91dGlsJyApO1xuXG47KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbiAgICB2YXIgd2lkZ2V0TmFtZSA9ICdic2UuY29sX2NvbGxhcHNlJyxcbiAgICAgICAgd2lkZ2V0Q2xhc3MgPSAnYnNlLWNvbC1jb2xsYXBzZScsXG4gICAgICAgIGNsYXNzZXMgPSB3aWRnZXRDbGFzcy5idWlsZE5hbWVzTWFwKFsnY29sbGFwc2VkJywgJ2ljb24nXSksXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydjb2xsYXBzZWQnLCAnaWNvbicsICdhZGQnLCAnY29udHJvbEFsbCcsICdjb250cm9sJywgJ2NvbnRyb2xMYWJlbCddLCAnLicpLFxuXG4gICAgICAgIG1hcmt1cCA9IHtcbiAgICAgICAgICAgIGV4cGFuZF9pY29uOiBbJzxzcGFuPicsIHsnY2xhc3MnOiBjbGFzc2VzLmljb24sICdhcmlhLWhpZGRlbic6ICd0cnVlJ31dLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGhlbHBlcnNcbiAgICAgICAgZXhwYW5kID0gZnVuY3Rpb24oZWwpe1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5jb2xsYXBzZWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb2xsYXBzZSA9IGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIGVsLmFkZENsYXNzKGNsYXNzZXMuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdG9nZ2xlQ29sbGFwc2VkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsLnRvZ2dsZUNsYXNzKGNsYXNzZXMuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmhhc0NsYXNzKGNsYXNzZXMuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcblxuICAgICQud2lkZ2V0KCB3aWRnZXROYW1lLCB7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0byBiZSB1c2VkIGFzIGRlZmF1bHRzXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvbnRyb2xfdGl0bGU6ICdFeHBhbmQvQ29sbGFwc2UgQ29sdW1uJyxcbiAgICAgICAgICAgIGNvbnRyb2xBbGxfdGl0bGU6ICdFeHBhbmQvQ29sbGFwc2UgQWxsJyxcbiAgICAgICAgICAgIGNvbnRyb2xBbGxfbGFiZWxzOiB7dHJ1ZTogJ0V4cGFuZCBBbGwnLCBmYWxzZTogJ0NvbGxhcHNlIEFsbCd9LCAgLy8gbnVsbCBvciBmYWxzZSB0byBsZWF2ZSBkZWZhdWx0XG4gICAgICAgICAgICBpY29uX2NsYXNzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbCBic2Utcm90YXRlLTQ1JyxcblxuICAgICAgICAgICAgLy8gZXZlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRlZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbmZpZ3VyZSBhbmQgcmV0dXJuIHRoZSB3aWRnZXQgY29udHJvbHNcbiAgICAgICAgX2NvbmZpZ3VyZUNvbnRyb2xzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZXhwYW5kX2ljb24gPSAkLmFwcGx5KHRoaXMsIG1hcmt1cC5leHBhbmRfaWNvbikuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmljb25fY2xhc3MpLFxuICAgICAgICAgICAgICAgIGNvbF9jb250cm9scyA9IHRoaXMuZWxlbWVudC5maW5kKHNlbGVjdG9ycy5jb250cm9sKSxcbiAgICAgICAgICAgICAgICBnbG9iYWxfY29udHJvbHMgPSB0aGlzLmVsZW1lbnQuZmluZChzZWxlY3RvcnMuY29udHJvbEFsbCk7XG5cbiAgICAgICAgICAgIGNvbF9jb250cm9scy5hcHBlbmQoZXhwYW5kX2ljb24uY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5jb250cm9sX3RpdGxlKTtcbiAgICAgICAgICAgIGdsb2JhbF9jb250cm9scy5wcmVwZW5kKGV4cGFuZF9pY29uLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCB0aGlzLm9wdGlvbnMuY29udHJvbEFsbF90aXRsZSk7XG4gICAgICAgICAgICBjb2xsYXBzZShnbG9iYWxfY29udHJvbHMpOyAgLy8gQXNzdW1lIGluaXRpYWwgc3RhdGUgZm9yIGdsb2JhbCBjb250cm9sIGlzIEV4cGFuZCBBbGw/XG4gICAgICAgICAgICBnbG9iYWxfY29udHJvbHMuZGF0YSgnY29udHJvbHMnLCBjb2xfY29udHJvbHMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2wgOiBjb2xfY29udHJvbHMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsIDogZ2xvYmFsX2NvbnRyb2xzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgY29sbGFwc2UgdGFyZ2V0cyBmb3IgZWFjaCBjb250cm9sIC0tIGkuZS4sIHRkIGVsZW1lbnRzIGluIHRoZSBzYW1lIGNvbHVtblxuICAgICAgICBfY29uZmlndXJlVGFyZ2V0cyA6IGZ1bmN0aW9uKGNvbF9jb250cm9scykge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gdGhpcy5lbGVtZW50LmlzKCd0YWJsZScpP3RoaXMuZWxlbWVudDp0aGlzLmVsZW1lbnQuZmluZCgndGFibGUnKVswXVxuICAgICAgICAgICAgdGFibGUuYWRkQ2xhc3Mod2lkZ2V0Q2xhc3MpO1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggY29udHJvbCwgZ2V0IGFsbCB0YXJnZXRzIGZyb20gaXRzIHRhYmxlIGNvbHVtbiAoIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvOFhTTEYvIClcbiAgICAgICAgICAgICQuZWFjaChjb2xfY29udHJvbHMsIGZ1bmN0aW9uKGlkeCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBjb2xOdW1iZXIgPSBjb250cm9sLnBhcmVudChcInRyXCIpLmNoaWxkcmVuKCkuaW5kZXgoY29udHJvbCksXG4gICAgICAgICAgICAgICAgICAgIHJvd3MgPSB0YWJsZS5maW5kKCc+IHRib2R5ID4gdHInKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHJvd3MuZmluZCgndGQ6bnRoLWNoaWxkKCcgKyAoY29sTnVtYmVyICsgMSkgKyAnKScpLmFkZChjb250cm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQ29sbGFwc2VkKGNvbnRyb2wpICkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZSh0YXJnZXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udHJvbC5kYXRhKCd0YXJnZXRzJywgdGFyZ2V0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmVudHMgaGFuZGxlZCBieSB0aGlzIHdpZGdldFxuICAgICAgICBfY29uZmlndXJlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5jb2wuY2xpY2soIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2dnbGVUYXJnZXRzKCQodGhpcyksIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5nbG9iYWwuY2xpY2soIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGV4cGFuZEFsbCA9IGlzQ29sbGFwc2VkKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICQuZWFjaChzZWxmLmNvbnRyb2xzLmNvbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZEFsbCA/IHNlbGYuZXhwYW5kVGFyZ2V0cygkKHRoaXMpLCBldmVudCk6c2VsZi5jb2xsYXBzZVRhcmdldHMoJCh0aGlzKSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxseSwgY2hhbmdlIGNvbnRyb2wncyBsYWJlbFxuICAgICAgICAgICAgICAgIHRvZ2dsZUNvbGxhcHNlZChjb250cm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRyb2xBbGxfbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGNvbnRyb2wuZmluZChzZWxlY3RvcnMuY29udHJvbExhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaHRtbChzZWxmLm9wdGlvbnMuY29udHJvbEFsbF9sYWJlbHNbaXNDb2xsYXBzZWQoY29udHJvbCldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDcmVhdGUgJywgd2lkZ2V0TmFtZSwgJ2luc3RhbmNlIGZvcicsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9nZXREYXRhT3B0aW9ucygpOyAvLyBpZiB3aWRnZXQgcmVjb2duaXplcyBkYXRhLSogb3B0aW9ucyBpbiBtYXJrdXBcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLl9jb25maWd1cmVDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlVGFyZ2V0cyh0aGlzLmNvbnRyb2xzLmNvbCk7XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVzdHJveSBwbHVnaW4gaW5zdGFuY2UgIGFuZCBjbGVhbiB1cCBtb2RpZmljYXRpb25zIHRoZSB3aWRnZXQgaGFzIG1hZGUgdG8gdGhlIERPTVxuICAgICAgICBfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0Rlc3Ryb3k6JywgdGhpcyk7XG4gICAgICAgICAgICAkKHNlbGVjdG9ycy5jb2xsYXBzZWQpLnJlbW92ZUNsYXNzKGNsYXNzZXMuY29sbGFwc2VkKTtcbiAgICAgICAgICAgICQoc2VsZWN0b3JzLmljb24pLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5jb2wuYXR0cigndGl0bGUnLCAnJykub2ZmKCdjbGljaycpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5nbG9iYWwuYXR0cigndGl0bGUnLCAnJykub2ZmKCdjbGljaycpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5jb2wuZGF0YSgndGFyZ2V0cycsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5nbG9iYWwuZGF0YSgnY29udHJvbHMnLCBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQdWJsaWMgbWV0aG9kc1xuICAgICAgICBleHBhbmRUYXJnZXRzIDogZnVuY3Rpb24oY29udHJvbCwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gY29udHJvbC5kYXRhKCd0YXJnZXRzJyk7XG4gICAgICAgICAgICBleHBhbmQodGFyZ2V0cyk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCAnZXhwYW5kZWQnLCBldmVudCwgeyBjb250cm9sOmNvbnRyb2wsIHRhcmdldHM6dGFyZ2V0cyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGFwc2VUYXJnZXRzIDogZnVuY3Rpb24oY29udHJvbCwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0gY29udHJvbC5kYXRhKCd0YXJnZXRzJyk7XG4gICAgICAgICAgICBjb2xsYXBzZSh0YXJnZXRzKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoICdjb2xsYXBzZWQnLCBldmVudCwgeyBjb250cm9sOmNvbnRyb2wsIHRhcmdldHM6dGFyZ2V0cyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVGFyZ2V0cyA6IGZ1bmN0aW9uKGNvbnRyb2wsIGV2ZW50KSB7XG4gICAgICAgICAgICBpc0NvbGxhcHNlZChjb250cm9sKSA/IHRoaXMuZXhwYW5kVGFyZ2V0cyhjb250cm9sLCBldmVudCkgOiB0aGlzLmNvbGxhcHNlVGFyZ2V0cyhjb250cm9sLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQoc2VsZWN0b3JzLmFkZCkuY29sX2NvbGxhcHNlKCk7XG5cbn0pKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTsiLCIvKipcbiAqIEVkaXQgVGhpcyBDb21wb25lbnQgKHYwLjEpOiBlZGl0LXRoaXMuanNcbiAqICAgLS0gdG9nZ2xlIGRpc3BsYXkgdmFsdWUgd2l0aCBlZGl0IGZvcm0gZm9yIHRoZSB2YWx1ZVxuICogICAtLSBvcHRpb25hbGx5LCBBSkFYIHNhdmUgZWRpdGVkIGZvcm0uXG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnlcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSggJy4vdXRpbCcgKTtcblxuOyhmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4gICAgdmFyIHdpZGdldE5hbWUgPSAnYnNlLmVkaXRfdGhpcycsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1lZGl0LXRoaXMnLFxuICAgICAgICBjbGFzc2VzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ2ljb24nLCAnY29udGVudCddKSxcbiAgICAgICAgc2VsZWN0b3JzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ2NvbnRlbnQnXSwgJy4nKSxcblxuICAgICAgICBtYXJrdXAgPSB7XG4gICAgICAgICAgICBlZGl0X2ljb246IFsnPHNwYW4+JywgeydjbGFzcyc6IGNsYXNzZXMuaWNvbiwgJ2FyaWEtaGlkZGVuJzogJ3RydWUnfV1cbiAgICAgICAgIH07XG5cbiAgICAkLndpZGdldCggd2lkZ2V0TmFtZSwge1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gYmUgdXNlZCBhcyBkZWZhdWx0c1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBhY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBpY29uX2NsYXNzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1lZGl0JyxcbiAgICAgICAgICAgIGljb25fdGl0bGU6ICdFZGl0IHRoaXMnLFxuXG4gICAgICAgICAgICAvLyBldmVudCBjYWxsYmFja3MgKGFqYXggZXZlbnQgY2FsbGJhY2tzIGFsc28gdHJpZ2dlcilcbiAgICAgICAgICAgIHNhdmVGb3JtOiBudWxsLCAgIC8vIGNhbGxlZCB3aGVuIHJhbmdlX2lucHV0IGlzIGNoYW5nZWQsIGJlZm9yZSBzYXZpbmcgLSByZXR1cm4gZmFsc2UgdG8gcHJldmVudCBkZWZhdWx0IGFjdGlvblxuICAgICAgICAgICAgc2hvd0Zvcm06IG51bGwsICAgLy8gY2FsbGVkIHdoZW4gZm9ybSBpcyBzaG93blxuICAgICAgICAgICAgaGlkZUZvcm06IG51bGwgICAgLy8gY2FsbGVkIHdoZW4gZm9ybSBpcyBoaWRkZW5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRlbnQgYXJlYSBmcm9tIHRoZSBjdXJyZW50IGZvcm0gdmFsdWUuXG4gICAgICAgIF91cGRhdGVDb250ZW50IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuaHRtbCh0aGlzLmZvcm1fY29udHJvbHMudmFsKCkpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZCh0aGlzLmVkaXRfaWNvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHRoZSB3aWRnZXQgY29udHJvbHMgKGVkaXQgaWNvbiBhbmQgZm9ybSBlbGVtZW50cylcbiAgICAgICAgX2NvbmZpZ3VyZUNvbnRyb2xzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmVsZW1lbnQuZmluZChzZWxlY3RvcnMuY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRfaWNvbiA9ICQuYXBwbHkodGhpcywgbWFya3VwLmVkaXRfaWNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaWNvbl9jbGFzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5pY29uX3RpdGxlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5hcHBlbmQodGhpcy5lZGl0X2ljb24pO1xuXG4gICAgICAgICAgICAvLyBBbmQgdGhlIGZvcm0uLi5cbiAgICAgICAgICAgIHZhciBmb3JtX2lkID0gdGhpcy5lbGVtZW50LmRhdGEoJ2Zvcm1faWQnKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9ICQoJyMnK2Zvcm1faWQpO1xuICAgICAgICAgICAgLy8gQ29uZmlndXJlIG9wdGlvbmFsIEFqYXggc2F2ZSB3aXRoIGNhbGxiYWNrIHRvIGhpZGUgdGhlIGZvcm0gb24gc3VjY2Vzc2Z1bCByZXF1ZXN0cy5cbiAgICAgICAgICAgIHRoaXMuZm9ybS5hamF4X3NhdmUoICQuZXh0ZW5kKHRoaXMub3B0aW9ucywge2FqYXhfc3VjY2Vzczp0aGlzLmhpZGVGb3JtLmJpbmQodGhpcyl9KSApO1xuXG4gICAgICAgICAgICAvLyAuLi4gbW92ZSBmb3JtIHRvIGVkaXQtdGhpcyBwYW5lbCAuLi5cbiAgICAgICAgICAgIHRoaXMuZm9ybV9jb250cm9scyA9IHRoaXMuZm9ybS5maW5kKCAnOmlucHV0JyApO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZvcm0uaGlkZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpcyB0aGUgdGFyZ2V0IGVsZW1lbnQgcGFydCBvZiB0aGUgd2lkZ2V0IGVsZW1lbnQ/XG4gICAgICAgIF9jb250YWlucyA6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jbG9zZXN0KHRoaXMuZWxlbWVudCkubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmVudHMgaGFuZGxlZCBieSB0aGlzIHdpZGdldFxuICAgICAgICBfY29uZmlndXJlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dGb3JtKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLmZvcm1fY29udHJvbHNbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaGlkZSBmb3JtIG9uIGNsaWNrcyB0aGF0IGFyZSBub3Qgd2l0aGluIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgJCgnYm9keScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9jb250YWlucygkKGV2ZW50LnRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZUZvcm0oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmZvcm0ub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ29udGVudCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVGb3JtKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ3JlYXRlIFwiLCB3aWRnZXROYW1lLCBcIiBpbnN0YW5jZSBmb3JcIiwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2FqYXhDb25maWcoKTtcbiAgICAgICAgICAgIHRoaXMuX2dldERhdGFPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmVDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlc3Ryb3kgcGx1Z2luIGluc3RhbmNlICBhbmQgY2xlYW4gdXAgbW9kaWZpY2F0aW9ucyB0aGUgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveTogXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRfaWNvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZUZvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICAgICAvLyBUTyBETzogcHV0IGZvcm0gYmFjayBmcm9tIHdoZW5jZSBpdCBjYW1lP1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gICAgICAgIHNob3dGb3JtIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uc2hvdygpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlciggJ3Nob3dGb3JtJywgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlRm9ybSA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0uaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnNob3coKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoICdoaWRlRm9ybScsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNGb3JtVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmlzKFwiOnZpc2libGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZUZvcm0gOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5pc0Zvcm1WaXNpYmxlKCkgPyB0aGlzLnNob3dGb3JtKGV2ZW50KSA6IHRoaXMuaGlkZUZvcm0oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9yc1t3aWRnZXRDbGFzc10pLmVkaXRfdGhpcygpO1xuXG59KSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cbiIsIi8qKlxuICogRXh0ZW5zaW9ucyBmb3IgalF1ZXJ5IFVJIFdpZGdldCBGYWN0b3J5XG4gKiAgICAtIF9nZXREYXRhT3B0aW9uczogIGxvYWQgb3B0aW9ucyBmcm9tIGRhdGEtb3B0aW9uIGF0dHJpYnV0ZXMgaW4gZWxlbWVudCdzIG1hcmt1cFxuICogICAgLSBfYWpheENvbmZpZ1xuICpcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldCcpO1xucmVxdWlyZSggJy4vdXRpbCcpO1xuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIGNvbnN0IGFqYXhfZXJyb3JfdGVtcGxhdGUgPVxuICAgICAgICAnPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmcgYWxlcnQtZGlzbWlzc2libGVcIiByb2xlPVwiYWxlcnRcIj4nICtcbiAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgZGF0YS1kaXNtaXNzPVwiYWxlcnRcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIj4nICtcbiAgICAgICAgICAgICAgICAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj4nICtcbiAgICAgICAgICAgICc8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICdPb3BzISBXZSBlbmNvdW50ZXJlZCBhbiBlcnJvciBwcm9jZXNzaW5nIHlvdXIgcmVxdWVzdDoge3RleHRTdGF0dXN9JyArXG4gICAgICAgICAgICAnPGJyPlJlZnJlc2ggcGFnZSBhbmQgdHJ5IGFnYWluPycgK1xuICAgICAgICAnPC9kaXY+JztcblxuICAgIHZhciBXaWRnZXRFeHRlbnNpb25zTWl4aW4gPSB7XG4gICAgICAgIC8vIExvYWQgYW55IGRhdGEtIGF0dHJpYnV0ZSBvcHRpb25zIGZyb20gdGhlIGVsZW1lbnQncyB0YWdcbiAgICAgICAgX2dldERhdGFPcHRpb25zIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YV9vcHRzID0gdGhpcy5lbGVtZW50LmRhdGEoKTtcbiAgICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhX29wdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHNba2V5XSA9IGRhdGFfb3B0c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgLypcbiAgICAgICAgICogU3RhbmRhcmRpemVkIGpRdWVyeS5hamF4IGNhbGxzIHdpdGggZGVmYXVsdCBiZWhhdmlvdXJzICsgdHJpZ2dlcnMgZm9yIEJTRSB3aWRnZXRzXG4gICAgICAgICAqICAgRS5nLiwgdGhpcy5hamF4X3N1Ym1pdF9mb3JtKHsgb3B0aW9uYWxfYWpheF9zZXR0aW5nc19vcl9vdmVycmlkZXMgfSlcbiAgICAgICAgICogICBBZGRzIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGFuZCB0cmlnZ2VyIGZvciBlYWNoIGxvY2FsIEFqYXggRXZlbnQuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIEFkZCBhamF4IHRyaWdnZXIgZXZlbnRzIHRvIHRoaXMgd2lkZ2V0J3Mgb3B0aW9uc1xuICAgICAgICBfYWpheENvbmZpZyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyZWQgYnkgYWpheCBjYWxscywgdXNlZCB0byBleHRlbmQgd2lkZ2V0IG9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGFqYXhfZXZlbnRfb3B0aW9ucz0ge1xuICAgICAgICAgICAgICAgIGFqYXhfYmVmb3JlU2VuZDogbnVsbCxcbiAgICAgICAgICAgICAgICBhamF4X3N1Y2Nlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgYWpheF9lcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBhamF4X2NvbXBsZXRlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIGFqYXhfZXZlbnRfb3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8vIFN1Ym1pdCB0aGlzLmZvcm0gYnkgYWpheCwgd2l0aCBhbiBvcHRpb25hbCB0aGlzLnNwaW5uZXIgdG8gZGlzcGxheSB3aGlsZSBsb2FkaW5nXG4gICAgICAgIF9hamF4U3VibWl0Rm9ybSA6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmZvcm0sIFwiQlNFIGFqYXhfc3VibWl0X2Zvcm0gRXJyb3I6IHRoaXMuZm9ybSBtdXN0IGJlIHNldCBvbiB3aWRnZXQuXCIpO1xuICAgICAgICAgICAgdmFyIGZvcm1fZGF0YSA9IHRoaXMuZm9ybS5zZXJpYWxpemUoKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGV4dHJhX2RhdGEgPSBzZXR0aW5ncy5kYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gc2V0dGluZ3MuYWN0aW9uIHx8IGZvcm0uYXR0cignYWN0aW9uJyksXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gc2V0dGluZ3MubWV0aG9kIHx8IGZvcm0uYXR0cignbWV0aG9kJykgfHwgJ1BPU1QnO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoYWN0aW9uLCBcIkJTRSBhamF4X3N1Ym1pdF9mb3JtIEVycm9yOiBhIGZvcm0gYWN0aW9uIG9wdGlvbiBtdXN0IGJlIHN1cHBsaWVkLlwiKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgYXJncyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IGFjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmb3JtX2RhdGEgKyBleHRyYV9kYXRhLFxuXG4gICAgICAgICAgICAgICAgLy8gQWpheCBldmVudHNcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNwaW5uZXIpIHNlbGYuc3Bpbm5lci5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kKSBzZXR0aW5ncy5iZWZvcmVTZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXIoJ2FqYXhfYmVmb3JlU2VuZCcsIG51bGwsIHtmb3JtX2RhdGE6IGZvcm1fZGF0YSwgYXJnczogYXJndW1lbnRzfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoanNvbiwgdGV4dFN0YXR1cywgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm1lc3NhZ2UpIHNlbGYuZm9ybS5iZWZvcmUoanNvbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN1Y2Nlc3MpIHNldHRpbmdzLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlcignYWpheF9zdWNjZXNzJywgbnVsbCwge2FyZ3M6IGFyZ3VtZW50c30pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZm9ybS5hZnRlcigkKGFqYXhfZXJyb3JfdGVtcGxhdGUuZm9ybWF0VW5pY29ybih7dGV4dFN0YXR1czogdGV4dFN0YXR1c30pKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHhoci5zdGF0dXMgKyBcIjogXCIgKyB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZXJyb3IpIHNldHRpbmdzLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXIoJ2FqYXhfZXJyb3InLCBudWxsLCB7YXJnczogYXJndW1lbnRzfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHhociwgdGV4dFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zcGlubmVyKSBzZWxmLnNwaW5uZXIuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29tcGxldGUpIHNldHRpbmdzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXIoJ2FqYXhfY29tcGxldGUnLCBudWxsLCB7YXJnczogYXJndW1lbnRzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJC5hamF4KGFyZ3MpO1xuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCdXaWRnZXQnIGluICQpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbigkLldpZGdldC5wcm90b3R5cGUsIFdpZGdldEV4dGVuc2lvbnNNaXhpbik7XG4gICAgfVxufSkoalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiIsIi8qISBqUXVlcnkgVUkgLSB2MS4xMi4xIC0gMjAxOC0wNi0wNVxuKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4qIEluY2x1ZGVzOiB3aWRnZXQuanMsIHBvc2l0aW9uLmpzXG4qIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgdmVyc2lvbiA9ICQudWkudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBXaWRnZXRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIHN0YXRlZnVsIHdpZGdldHMgd2l0aCBhIGNvbW1vbiBBUEkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS93aWRnZXQvXG5cblxuXG52YXIgd2lkZ2V0VXVpZCA9IDA7XG52YXIgd2lkZ2V0U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gKCBmdW5jdGlvbiggb3JpZyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZXZlbnRzLCBlbGVtLCBpO1xuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxuXHRcdFx0XHRldmVudHMgPSAkLl9kYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0XHRcdGlmICggZXZlbnRzICYmIGV2ZW50cy5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH1cblx0XHRvcmlnKCBlbGVtcyApO1xuXHR9O1xufSApKCAkLmNsZWFuRGF0YSApO1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZTtcblxuXHQvLyBQcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdHZhciBwcm94aWVkUHJvdG90eXBlID0ge307XG5cblx0dmFyIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0dmFyIGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdGlmICggJC5pc0FycmF5KCBwcm90b3R5cGUgKSApIHtcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblxuXHRcdC8vIENvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cblx0XHQvLyBUcmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSApO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXG5cdC8vIFdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIF9zdXBlcigpIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBfc3VwZXJBcHBseSggYXJncyApIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR2YXIgX19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseTtcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSApKCk7XG5cdH0gKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoIGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSApIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0gKTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIFJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3Rvcixcblx0XHRcdFx0Y2hpbGQuX3Byb3RvICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0dmFyIGlucHV0SW5kZXggPSAwO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBrZXk7XG5cdHZhciB2YWx1ZTtcblxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIjtcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciByZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGluc3RhbmNlIG1ldGhvZFxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2Vcblx0XHRcdGlmICggIXRoaXMubGVuZ3RoICYmIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2VbIG9wdGlvbnMgXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRcdGlmICggYXJncy5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdCggYXJncyApICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKTtcblx0XHRcdFx0XHRpZiAoIGluc3RhbmNlLl9pbml0ICkge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2UuX2luaXQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge30sXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gd2lkZ2V0VXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cdFx0dGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCA9IHt9O1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cblx0XHRcdFx0Ly8gRWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbIDAgXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WyAwIF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cblx0X2NyZWF0ZTogJC5ub29wLFxuXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdCQuZWFjaCggdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggdmFsdWUsIGtleSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBDbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3Mub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleTtcblx0XHR2YXIgcGFydHM7XG5cdFx0dmFyIGN1ck9wdGlvbjtcblx0XHR2YXIgaTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiY2xhc3Nlc1wiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uRGlzYWJsZWQoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbkNsYXNzZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NLZXksIGVsZW1lbnRzLCBjdXJyZW50RWxlbWVudHM7XG5cblx0XHRmb3IgKCBjbGFzc0tleSBpbiB2YWx1ZSApIHtcblx0XHRcdGN1cnJlbnRFbGVtZW50cyA9IHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzS2V5IF07XG5cdFx0XHRpZiAoIHZhbHVlWyBjbGFzc0tleSBdID09PSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1sgY2xhc3NLZXkgXSB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMgfHxcblx0XHRcdFx0XHQhY3VycmVudEVsZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGFyZSBkb2luZyB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBqUXVlcnkgb2JqZWN0IGJlY2F1c2UgdGhlIF9yZW1vdmVDbGFzcygpIGNhbGxcblx0XHRcdC8vIG9uIHRoZSBuZXh0IGxpbmUgaXMgZ29pbmcgdG8gZGVzdHJveSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRzIGJlaW5nXG5cdFx0XHQvLyB0cmFja2VkLiBXZSBuZWVkIHRvIHNhdmUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgdGhlIG5ldyBjbGFzc2VzXG5cdFx0XHQvLyBiZWxvdy5cblx0XHRcdGVsZW1lbnRzID0gJCggY3VycmVudEVsZW1lbnRzLmdldCgpICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggY3VycmVudEVsZW1lbnRzLCBjbGFzc0tleSApO1xuXG5cdFx0XHQvLyBXZSBkb24ndCB1c2UgX2FkZENsYXNzKCkgaGVyZSwgYmVjYXVzZSB0aGF0IHVzZXMgdGhpcy5vcHRpb25zLmNsYXNzZXNcblx0XHRcdC8vIGZvciBnZW5lcmF0aW5nIHRoZSBzdHJpbmcgb2YgY2xhc3Nlcy4gV2Ugd2FudCB0byB1c2UgdGhlIHZhbHVlIHBhc3NlZCBpbiBmcm9tXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCksIHRoaXMgaXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2xhc3NlcyBvcHRpb24gd2hpY2ggd2FzIHBhc3NlZCB0b1xuXHRcdFx0Ly8gX3NldE9wdGlvbigpLiBXZSBwYXNzIHRoaXMgdmFsdWUgZGlyZWN0bHkgdG8gX2NsYXNzZXMoKS5cblx0XHRcdGVsZW1lbnRzLmFkZENsYXNzKCB0aGlzLl9jbGFzc2VzKCB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnRzLFxuXHRcdFx0XHRrZXlzOiBjbGFzc0tleSxcblx0XHRcdFx0Y2xhc3NlczogdmFsdWUsXG5cdFx0XHRcdGFkZDogdHJ1ZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCwgISF2YWx1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXG5cdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhvdmVyYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5mb2N1c2FibGUsIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKCB7IGRpc2FibGVkOiBmYWxzZSB9ICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IHRydWUgfSApO1xuXHR9LFxuXG5cdF9jbGFzc2VzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgZnVsbCA9IFtdO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0Y2xhc3NlczogdGhpcy5vcHRpb25zLmNsYXNzZXMgfHwge31cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NTdHJpbmcoIGNsYXNzZXMsIGNoZWNrT3B0aW9uICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSB8fCAkKCk7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hZGQgKSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlKCBjdXJyZW50LmdldCgpLmNvbmNhdCggb3B0aW9ucy5lbGVtZW50LmdldCgpICkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnJlbnQgPSAkKCBjdXJyZW50Lm5vdCggb3B0aW9ucy5lbGVtZW50ICkuZ2V0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdGZ1bGwucHVzaCggY2xhc3Nlc1sgaSBdICk7XG5cdFx0XHRcdGlmICggY2hlY2tPcHRpb24gJiYgb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApIHtcblx0XHRcdFx0XHRmdWxsLnB1c2goIG9wdGlvbnMuY2xhc3Nlc1sgY2xhc3Nlc1sgaSBdIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX29uKCBvcHRpb25zLmVsZW1lbnQsIHtcblx0XHRcdFwicmVtb3ZlXCI6IFwiX3VudHJhY2tDbGFzc2VzRWxlbWVudFwiXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmtleXMgKSB7XG5cdFx0XHRwcm9jZXNzQ2xhc3NTdHJpbmcoIG9wdGlvbnMua2V5cy5tYXRjaCggL1xcUysvZyApIHx8IFtdLCB0cnVlICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5leHRyYSApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5leHRyYS5tYXRjaCggL1xcUysvZyApIHx8IFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bGwuam9pbiggXCIgXCIgKTtcblx0fSxcblxuXHRfdW50cmFja0NsYXNzZXNFbGVtZW50OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggdGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZXZlbnQudGFyZ2V0LCB2YWx1ZSApICE9PSAtMSApIHtcblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsga2V5IF0gPSAkKCB2YWx1ZS5ub3QoIGV2ZW50LnRhcmdldCApLmdldCgpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZW1vdmVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhICkge1xuXHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggZWxlbWVudCwga2V5cywgZXh0cmEsIGZhbHNlICk7XG5cdH0sXG5cblx0X2FkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF90b2dnbGVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhLCBhZGQgKSB7XG5cdFx0YWRkID0gKCB0eXBlb2YgYWRkID09PSBcImJvb2xlYW5cIiApID8gYWRkIDogZXh0cmE7XG5cdFx0dmFyIHNoaWZ0ID0gKCB0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIiB8fCBlbGVtZW50ID09PSBudWxsICksXG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRleHRyYTogc2hpZnQgPyBrZXlzIDogZXh0cmEsXG5cdFx0XHRcdGtleXM6IHNoaWZ0ID8gZWxlbWVudCA6IGtleXMsXG5cdFx0XHRcdGVsZW1lbnQ6IHNoaWZ0ID8gdGhpcy5lbGVtZW50IDogZWxlbWVudCxcblx0XHRcdFx0YWRkOiBhZGRcblx0XHRcdH07XG5cdFx0b3B0aW9ucy5lbGVtZW50LnRvZ2dsZUNsYXNzKCB0aGlzLl9jbGFzc2VzKCBvcHRpb25zICksIGFkZCApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudDtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gTm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBObyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblxuXHRcdFx0XHQvLyBBbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihbXFx3Oi1dKilcXHMqKC4qKSQvICk7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbWF0Y2hbIDEgXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50Lm9uKCBldmVudE5hbWUsIHNlbGVjdG9yLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQub24oIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKCBldmVudE5hbWUgfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcblx0XHRcdHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC5vZmYoIGV2ZW50TmFtZSApLm9mZiggZXZlbnROYW1lICk7XG5cblx0XHQvLyBDbGVhciB0aGUgc3RhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzICgjMTAwNTYpXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoIHRoaXMuYmluZGluZ3Mubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCB0aGlzLmhvdmVyYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnO1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBUaGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBoYXNPcHRpb25zO1xuXHRcdHZhciBlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0bWV0aG9kIDpcblx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZSggZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG52YXIgd2lkZ2V0ID0gJC53aWRnZXQ7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wb3NpdGlvbi9cbiAqL1xuXG4vLz4+bGFiZWw6IFBvc2l0aW9uXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogUG9zaXRpb25zIGVsZW1lbnRzIHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuXG5cbiggZnVuY3Rpb24oKSB7XG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cmhvcml6b250YWwgPSAvbGVmdHxjZW50ZXJ8cmlnaHQvLFxuXHRydmVydGljYWwgPSAvdG9wfGNlbnRlcnxib3R0b20vLFxuXHRyb2Zmc2V0ID0gL1tcXCtcXC1dXFxkKyhcXC5bXFxkXSspPyU/Lyxcblx0cnBvc2l0aW9uID0gL15cXHcrLyxcblx0cnBlcmNlbnQgPSAvJSQvLFxuXHRfcG9zaXRpb24gPSAkLmZuLnBvc2l0aW9uO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKCBvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0ICkge1xuXHRyZXR1cm4gW1xuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDAgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAwIF0gKSA/IHdpZHRoIC8gMTAwIDogMSApLFxuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDEgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAxIF0gKSA/IGhlaWdodCAvIDEwMCA6IDEgKVxuXHRdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzcyggZWxlbWVudCwgcHJvcGVydHkgKSB7XG5cdHJldHVybiBwYXJzZUludCggJC5jc3MoIGVsZW1lbnQsIHByb3BlcnR5ICksIDEwICkgfHwgMDtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyggZWxlbSApIHtcblx0dmFyIHJhdyA9IGVsZW1bIDAgXTtcblx0aWYgKCByYXcubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH1cblx0XHR9O1xuXHR9XG5cdGlmICggJC5pc1dpbmRvdyggcmF3ICkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLCBsZWZ0OiBlbGVtLnNjcm9sbExlZnQoKSB9XG5cdFx0fTtcblx0fVxuXHRpZiAoIHJhdy5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiByYXcucGFnZVksIGxlZnQ6IHJhdy5wYWdlWCB9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRoZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcblx0fTtcbn1cblxuJC5wb3NpdGlvbiA9IHtcblx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdFx0dmFyIHcxLCB3Mixcblx0XHRcdGRpdiA9ICQoIFwiPGRpdiBcIiArXG5cdFx0XHRcdFwic3R5bGU9J2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpoaWRkZW47Jz5cIiArXG5cdFx0XHRcdFwiPGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVsgMCBdO1xuXG5cdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIGRpdiApO1xuXHRcdHcxID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cdFx0ZGl2LmNzcyggXCJvdmVyZmxvd1wiLCBcInNjcm9sbFwiICk7XG5cblx0XHR3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXG5cdFx0aWYgKCB3MSA9PT0gdzIgKSB7XG5cdFx0XHR3MiA9IGRpdlsgMCBdLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdGRpdi5yZW1vdmUoKTtcblxuXHRcdHJldHVybiAoIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gdzEgLSB3MiApO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxXaWR0aCApLFxuXHRcdFx0aGFzT3ZlcmZsb3dZID0gb3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dZID09PSBcImF1dG9cIiAmJiB3aXRoaW4uaGVpZ2h0IDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxIZWlnaHQgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGhhc092ZXJmbG93WSA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcblx0XHR9O1xuXHR9LFxuXHRnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgd2l0aGluRWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgd2luZG93ICksXG5cdFx0XHRpc1dpbmRvdyA9ICQuaXNXaW5kb3coIHdpdGhpbkVsZW1lbnRbIDAgXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOSxcblx0XHRcdGhhc09mZnNldCA9ICFpc1dpbmRvdyAmJiAhaXNEb2N1bWVudDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IGhhc09mZnNldCA/ICQoIGVsZW1lbnQgKS5vZmZzZXQoKSA6IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0XHRzY3JvbGxMZWZ0OiB3aXRoaW5FbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdHNjcm9sbFRvcDogd2l0aGluRWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdHdpZHRoOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogd2l0aGluRWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fVxufTtcblxuJC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoICFvcHRpb25zIHx8ICFvcHRpb25zLm9mICkge1xuXHRcdHJldHVybiBfcG9zaXRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0Ly8gTWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xuXHRvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIGF0T2Zmc2V0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRPZmZzZXQsIGJhc2VQb3NpdGlvbiwgZGltZW5zaW9ucyxcblx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLm9mICksXG5cdFx0d2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKCBvcHRpb25zLndpdGhpbiApLFxuXHRcdHNjcm9sbEluZm8gPSAkLnBvc2l0aW9uLmdldFNjcm9sbEluZm8oIHdpdGhpbiApLFxuXHRcdGNvbGxpc2lvbiA9ICggb3B0aW9ucy5jb2xsaXNpb24gfHwgXCJmbGlwXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRvZmZzZXRzID0ge307XG5cblx0ZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIHRhcmdldCApO1xuXHRpZiAoIHRhcmdldFsgMCBdLnByZXZlbnREZWZhdWx0ICkge1xuXG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXG5cdC8vIENsb25lIHRvIHJldXNlIG9yaWdpbmFsIHRhcmdldE9mZnNldCBsYXRlclxuXHRiYXNlUG9zaXRpb24gPSAkLmV4dGVuZCgge30sIHRhcmdldE9mZnNldCApO1xuXG5cdC8vIEZvcmNlIG15IGFuZCBhdCB0byBoYXZlIHZhbGlkIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHBvc2l0aW9uc1xuXHQvLyBpZiBhIHZhbHVlIGlzIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2VudGVyXG5cdCQuZWFjaCggWyBcIm15XCIsIFwiYXRcIiBdLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gKCBvcHRpb25zWyB0aGlzIF0gfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCxcblx0XHRcdHZlcnRpY2FsT2Zmc2V0O1xuXG5cdFx0aWYgKCBwb3MubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyBSZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0gKTtcblxuXHQvLyBOb3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxuXHRpZiAoIGNvbGxpc2lvbi5sZW5ndGggPT09IDEgKSB7XG5cdFx0Y29sbGlzaW9uWyAxIF0gPSBjb2xsaXNpb25bIDAgXTtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gdGFyZ2V0V2lkdGg7XG5cdH0gZWxzZSBpZiAoIG9wdGlvbnMuYXRbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XG5cdH1cblxuXHRpZiAoIG9wdGlvbnMuYXRbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0IC8gMjtcblx0fVxuXG5cdGF0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5hdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCApO1xuXHRiYXNlUG9zaXRpb24ubGVmdCArPSBhdE9mZnNldFsgMCBdO1xuXHRiYXNlUG9zaXRpb24udG9wICs9IGF0T2Zmc2V0WyAxIF07XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbGxpc2lvblBvc2l0aW9uLCB1c2luZyxcblx0XHRcdGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRcdGVsZW1IZWlnaHQgPSBlbGVtLm91dGVySGVpZ2h0KCksXG5cdFx0XHRtYXJnaW5MZWZ0ID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRtYXJnaW5Ub3AgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0Y29sbGlzaW9uV2lkdGggPSBlbGVtV2lkdGggKyBtYXJnaW5MZWZ0ICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luUmlnaHRcIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby53aWR0aCxcblx0XHRcdGNvbGxpc2lvbkhlaWdodCA9IGVsZW1IZWlnaHQgKyBtYXJnaW5Ub3AgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Cb3R0b21cIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby5oZWlnaHQsXG5cdFx0XHRwb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgYmFzZVBvc2l0aW9uICksXG5cdFx0XHRteU9mZnNldCA9IGdldE9mZnNldHMoIG9mZnNldHMubXksIGVsZW0ub3V0ZXJXaWR0aCgpLCBlbGVtLm91dGVySGVpZ2h0KCkgKTtcblxuXHRcdGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aCAvIDI7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiYm90dG9tXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldFsgMCBdO1xuXHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldFsgMSBdO1xuXG5cdFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XG5cdFx0XHRtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuXHRcdFx0bWFyZ2luVG9wOiBtYXJnaW5Ub3Bcblx0XHR9O1xuXG5cdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBkaXIgKSB7XG5cdFx0XHRpZiAoICQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF0gKSB7XG5cdFx0XHRcdCQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF1bIGRpciBdKCBwb3NpdGlvbiwge1xuXHRcdFx0XHRcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcblx0XHRcdFx0XHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcblx0XHRcdFx0XHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXG5cdFx0XHRcdFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXG5cdFx0XHRcdFx0b2Zmc2V0OiBbIGF0T2Zmc2V0WyAwIF0gKyBteU9mZnNldFsgMCBdLCBhdE9mZnNldCBbIDEgXSArIG15T2Zmc2V0WyAxIF0gXSxcblx0XHRcdFx0XHRteTogb3B0aW9ucy5teSxcblx0XHRcdFx0XHRhdDogb3B0aW9ucy5hdCxcblx0XHRcdFx0XHR3aXRoaW46IHdpdGhpbixcblx0XHRcdFx0XHRlbGVtOiBlbGVtXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNpbmcgKSB7XG5cblx0XHRcdC8vIEFkZHMgZmVlZGJhY2sgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHVzaW5nIGNhbGxiYWNrLCBpZiBwcmVzZW50XG5cdFx0XHR1c2luZyA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCAtIHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgdGFyZ2V0V2lkdGggLSBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0dG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyB0YXJnZXRIZWlnaHQgLSBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGZlZWRiYWNrID0ge1xuXHRcdFx0XHRcdFx0dGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGVmdDogdGFyZ2V0T2Zmc2V0LmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHRhcmdldEhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbSxcblx0XHRcdFx0XHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbUhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IHJpZ2h0IDwgMCA/IFwibGVmdFwiIDogbGVmdCA+IDAgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdFx0dmVydGljYWw6IGJvdHRvbSA8IDAgPyBcInRvcFwiIDogdG9wID4gMCA/IFwiYm90dG9tXCIgOiBcIm1pZGRsZVwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCB0YXJnZXRXaWR0aCA8IGVsZW1XaWR0aCAmJiBhYnMoIGxlZnQgKyByaWdodCApIDwgdGFyZ2V0V2lkdGggKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaG9yaXpvbnRhbCA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyggdG9wICsgYm90dG9tICkgPCB0YXJnZXRIZWlnaHQgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2sudmVydGljYWwgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF4KCBhYnMoIGxlZnQgKSwgYWJzKCByaWdodCApICkgPiBtYXgoIGFicyggdG9wICksIGFicyggYm90dG9tICkgKSApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcImhvcml6b250YWxcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcInZlcnRpY2FsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCB0aGlzLCBwcm9wcywgZmVlZGJhY2sgKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZWxlbS5vZmZzZXQoICQuZXh0ZW5kKCBwb3NpdGlvbiwgeyB1c2luZzogdXNpbmcgfSApICk7XG5cdH0gKTtcbn07XG5cbiQudWkucG9zaXRpb24gPSB7XG5cdGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc0xlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHdpZGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uV2lkdGggPiBvdXRlcldpZHRoICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIGxlZnQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IDAgJiYgb3ZlclJpZ2h0IDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLVxuXHRcdFx0XHRcdFx0d2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQgLSBuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciByaWdodCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9vIGZhciBsZWZ0IC0+IGFsaWduIHdpdGggbGVmdCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyTGVmdCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XG5cblx0XHRcdC8vIFRvbyBmYXIgcmlnaHQgLT4gYWxpZ24gd2l0aCByaWdodCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG92ZXJUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC1cblx0XHRcdFx0XHRcdHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICYmIG92ZXJUb3AgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3RoIHRvcCBhbmQgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggb3ZlclRvcCA+IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQgKyBvdXRlckhlaWdodCAtIGRhdGEuY29sbGlzaW9uSGVpZ2h0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblxuXHRcdFx0Ly8gVG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgLT0gb3ZlckJvdHRvbTtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCA9IG1heCggcG9zaXRpb24udG9wIC0gY29sbGlzaW9uUG9zVG9wLCBwb3NpdGlvbi50b3AgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXA6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQubGVmdCArIHdpdGhpbi5zY3JvbGxMZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IGNvbGxpc2lvblBvc0xlZnQgLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRteU9mZnNldCA9IGRhdGEubXlbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLmF0WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAwIF0sXG5cdFx0XHRcdG5ld092ZXJSaWdodCxcblx0XHRcdFx0bmV3T3ZlckxlZnQ7XG5cblx0XHRcdGlmICggb3ZlckxlZnQgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uV2lkdGggLVxuXHRcdFx0XHRcdG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArXG5cdFx0XHRcdFx0YXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRMZWZ0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJMZWZ0ID4gMCB8fCBhYnMoIG5ld092ZXJMZWZ0ICkgPCBvdmVyUmlnaHQgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC50b3AgKyB3aXRoaW4uc2Nyb2xsVG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IHdpdGhpbi5oZWlnaHQsXG5cdFx0XHRcdG9mZnNldFRvcCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSBjb2xsaXNpb25Qb3NUb3AgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHR0b3AgPSBkYXRhLm15WyAxIF0gPT09IFwidG9wXCIsXG5cdFx0XHRcdG15T2Zmc2V0ID0gdG9wID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLm15WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMSBdID09PSBcInRvcFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAxIF0sXG5cdFx0XHRcdG5ld092ZXJUb3AsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cdFx0XHRpZiAoIG92ZXJUb3AgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC1cblx0XHRcdFx0XHRvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyQm90dG9tIDwgMCB8fCBuZXdPdmVyQm90dG9tIDwgYWJzKCBvdmVyVG9wICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICtcblx0XHRcdFx0XHRvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggbmV3T3ZlclRvcCA+IDAgfHwgYWJzKCBuZXdPdmVyVG9wICkgPCBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwZml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9XG59O1xuXG59ICkoKTtcblxudmFyIHBvc2l0aW9uID0gJC51aS5wb3NpdGlvbjtcblxuXG5cblxufSkpOyIsIi8qKlxuICogQm9vdHN0cmFwIEV4dHJhcyAodjAuMSk6IG1haW4uanNcbiAqICAgLS0gQ29sbGF0ZSBhbGwgY29tcG9uZW50IHNjcmlwdHMgdmlhIEJyb3N3ZXJpZnkgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnJvd3NlcmlmeVxuICpcbiAqICAgRXh0ZXJuYWwgRGVwZW5kZW5jaWVzOiAgQm9vdHN0cmFwIDMgKyBKUXVlcnkgMitcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxucmVxdWlyZSgnLi9hamF4X3NhdmUnKTtcbnJlcXVpcmUoJy4vZWRpdC10aGlzJyk7XG5yZXF1aXJlKCcuL2NvbF9jb2xsYXBzZScpO1xucmVxdWlyZSgnLi9wcm9ncmVzc19yZXBvcnQnKTtcbnJlcXVpcmUoJy4vc3Bpbm5lcicpO1xuIiwiLyoqXG4gKiBQcm9ncmVzcyBSZXBvcnQgQ29tcG9uZW50ICh2MC4xKTogcHJvZ3Jlc3NfcmVwb3J0LmpzXG4gKiAgIC0tIGEgQm9vdHN0cmFwIFByb2dyZXNzIEJhciB3aXRoIGFuIGludGVyYWN0aXZlIHJhbmdlIGlucHV0XG4gKiAgIC0tIEFKQVggc2F2ZSBzZWxlY3RlZCB2YWx1ZSB1c2luZyBzdGFuZGFyZCBITVRMIGZvcm0uXG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnkgKyBzcGlubmVyXG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5yZXF1aXJlKCAnLi9zcGlubmVyJyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0Jyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoICcuL3V0aWwnICk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS5wcm9ncmVzc19yZXBvcnQnLFxuICAgICAgICB3aWRnZXRDbGFzcyA9ICdic2UtcHJvZ3Jlc3MtcmVwb3J0JyxcbiAgICAgICAgY2xhc3NlcyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydwYW5lbCcsICdmb3JtJywgJ3ZhbHVlJ10pLFxuICAgICAgICBzZWxlY3RvcnMgPSB3aWRnZXRDbGFzcy5idWlsZE5hbWVzTWFwKFsnd3JhcCddLCAnLicpLFxuXG4gICAgICAgIG1hcmt1cCA9IHtcbiAgICAgICAgICAgIHBhbmVsIDogWyc8ZGl2PicsIHsnY2xhc3MnOiBjbGFzc2VzLnBhbmVsfV0sXG4gICAgICAgICAgICBmb3JtIDogWyc8Zm9ybT4nLCB7J2NsYXNzJzogY2xhc3Nlcy5mb3JtfV0sXG4gICAgICAgICAgICBpbnB1dCA6IFsnPGlucHV0PicsIHt0eXBlOidyYW5nZScsICdjbGFzcyc6IHdpZGdldENsYXNzLCBuYW1lOmNsYXNzZXMudmFsdWUsIHJlcXVpcmVkOicnfV1cbiAgICAgICAgfTtcblxuICAgICQud2lkZ2V0KCB3aWRnZXROYW1lLCB7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0byBiZSB1c2VkIGFzIGRlZmF1bHRzXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuXG4gICAgICAgICAgICAvLyBldmVudCBjYWxsYmFja3MgKGFqYXggZXZlbnQgY2FsbGJhY2tzIGFsc28gdHJpZ2dlcilcbiAgICAgICAgICAgIHNhdmVGb3JtOiBudWxsICAgLy8gY2FsbGVkIHdoZW4gcmFuZ2VfaW5wdXQgaXMgY2hhbmdlZCwgYmVmb3JlIHNhdmluZyAtIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGVtcGxhdGUgbm9kZSBmb3IgdGhlIHdpZGdldFxuICAgICAgICBfdGVtcGxhdGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLmVsZW1lbnQuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NfYmFyID0gdGhpcy5wcm9ncmVzcy5maW5kKCcucHJvZ3Jlc3MtYmFyJyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5wcm9ncmVzc19iYXIuYXR0cignYXJpYS12YWx1ZW5vdycpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZV9pbnB1dCA9ICQuYXBwbHkodGhpcywgbWFya3VwLmlucHV0KTsgIC8vICQoLi4ubWFya3VwLmlucHV0KVxuICAgICAgICAgICAgdGhpcy5mb3JtID0gJC5hcHBseSh0aGlzLCBtYXJrdXAuZm9ybSkuYXBwZW5kKHRoaXMucmFuZ2VfaW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5wYW5lbCA9ICQuYXBwbHkodGhpcywgbWFya3VwLnBhbmVsKS5hcHBlbmQodGhpcy5wcm9ncmVzcykuYXBwZW5kKHRoaXMuZm9ybSk7XG5cbiAgICAgICAgICAgIC8vIENvbmZpZ3VyZSBvcHRpb25hbCBBamF4IHNhdmUgd2l0aCBjYWxsYmFjayB0byBoaWRlIGZvcm0gb24gc3VjY2Vzc2Z1bCByZXF1ZXN0cy5cbiAgICAgICAgICAgIHRoaXMuZm9ybS5hamF4X3NhdmUoICQuZXh0ZW5kKHRoaXMub3B0aW9ucywge2FqYXhfc3VjY2Vzczp0aGlzLmZvcm0uaGlkZS5iaW5kKHRoaXMuZm9ybSl9KSApO1xuICAgICAgICAgICAgdGhpcy5yYW5nZV9pbnB1dC5hdHRyKCdtaW4nLCB0aGlzLm9wdGlvbnMubWluKS5hdHRyKCdtYXgnLCB0aGlzLm9wdGlvbnMubWF4KTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VfaW5wdXQudmFsKHRoaXMudmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmVudHMgaGFuZGxlZCBieSB0aGlzIHdpZGdldFxuICAgICAgICBfY29uZmlndXJlRXZlbnRIYW5kbGVycyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNwaW5uZXIgPSBzZWxmLmZvcm0uc3Bpbm5lcignaW5zdGFuY2UnKTsgIC8vIG91Y2ggLSB0aWdodCBjb3VwbGluZyB0byBhamF4LXNhdmUgaGVyZS5cblxuICAgICAgICAgICAgdGhpcy5yYW5nZV9pbnB1dC5vbignaW5wdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYudmFsdWUgPSBzZWxmLnJhbmdlX2lucHV0LnZhbCgpIHx8IDA7XG4gICAgICAgICAgICAgICAgc2VsZi5wcm9ncmVzc19iYXIudGV4dChzZWxmLnZhbHVlICsgJyUgQ29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnByb2dyZXNzX2Jhci5jc3MoICd3aWR0aCcsIHNlbGYudmFsdWUrJyUnKTtcbiAgICAgICAgICAgICAgICBzcGlubmVyLnBvc2l0aW9uKCB7dG9wOiAnLTFlbScsIGxlZnQ6KHNlbGYudmFsdWUtMSkrJyUnfSApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3Mub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZvcm0uc2hvdygpO1xuICAgICAgICAgICAgICAgIHNlbGYucmFuZ2VfaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJhbmdlX2lucHV0LmJsdXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgc2VsZi5mb3JtLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmZvcm0ub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZm9ybS5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdpZGdldCBpbnN0YW5jZSAoZS5nLiBlbGVtZW50IGNyZWF0aW9uLCBhcHBseSB0aGVtaW5nLCBiaW5kIGV2ZW50cyBldGMuKVxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNyZWF0ZSBcIiwgd2lkZ2V0TmFtZSwgXCIgaW5zdGFuY2UgZm9yXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9hamF4Q29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLl9nZXREYXRhT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFmdGVyKHRoaXMuX3RlbXBsYXRlKCkpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXN0cm95IHBsdWdpbiBpbnN0YW5jZSAgYW5kIGNsZWFuIHVwIG1vZGlmaWNhdGlvbnMgdGhlIHdpZGdldCBoYXMgbWFkZSB0byB0aGUgRE9NXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlc3Ryb3k6IFwiLCB0aGlzLnBhbmVsKTtcbiAgICAgICAgICAgIHRoaXMucGFuZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2hvdygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9ycy53cmFwKS5wcm9ncmVzc19yZXBvcnQoKTtcblxufSkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXG4iLCIvKipcbiAqIEFKQVggTG9hZGluZyBTcGlubmVyICh2MC4xKTogc3Bpbm5lci5qc1xuICogICAtLSBhIEpRdWVyeSBwbHVnaW4gc3Bpbm5lciB0byBzaWduYWwgYXN5biByZXF1ZXN0IGluLXByb2dyZXNzXG4gKiAgIC0tIHNob3cgLyBoaWRlIHNwaW5uZXIgY2FuIG9wdGlvbmFsbHkgY29udHJvbCBlbmFibGUvZGlzYWJsZSB3aWRnZXQncyBlbGVtZW50XG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnlcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldCcpO1xucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldC1leHRlbnNpb25zJyk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS5zcGlubmVyJyxcbiAgICAgICAgd2lkZ2V0Q2xhc3MgPSAnYnNlLXNwaW5uZXInLFxuICAgICAgICBzZWxlY3RvcnMgPSB7XG4gICAgICAgICAgICAnYXBwZW5kJyA6ICcuJyt3aWRnZXRDbGFzcysnLWFwcGVuZCdcbiAgICAgICAgfSxcbiAgICAgICAgbWFya3VwID0ge1xuICAgICAgICAgICAgc3Bpbm5lcjogWyc8c3Bhbj4nLCB7J2NsYXNzJzogd2lkZ2V0Q2xhc3N9XVxuICAgICAgICB9O1xuXG4gICAgJC53aWRnZXQoIHdpZGdldE5hbWUsIHtcblxuICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc3Bpbl90ZXh0OiAnU2F2aW5nLi4uJywgIC8vIHRpdGxlIGFuZCBhY2Nlc3NpYmlsaXR5IHRleHQgZm9yIHNwaW5uZXJcbiAgICAgICAgICAgIGRpc2FibGVfb25fc3BpbjogZmFsc2UsICAvLyBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGFsbCA6aW5wdXRzIGluIHRoZSBwYXJlbnQgZWxlbWVudCB3aGVuIHNwaW5uZXIgc2hvd3NcblxuICAgICAgICAgICAgLy8gZXZlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICBoaWRkZW46IG51bGwsICAgLy8gdHJpZ2dlcnMgd2hlbiBzcGlubmVyIGlzIGhpZGRlblxuICAgICAgICAgICAgc2hvd246IG51bGwgICAgIC8vIHRyaWdnZXJzIHdoZW4gc3Bpbm5lciBpcyBzaG93blxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRlbXBsYXRlIG5vZGUgZm9yIHRoZSB3aWRnZXRcbiAgICAgICAgX3RlbXBsYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5hcHBseSh0aGlzLCBtYXJrdXAuc3Bpbm5lcikuaGlkZSgpLmh0bWwodGhpcy5vcHRpb25zLnNwaW5fdGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERpc2FibGVUYXJnZXRzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlX29uX3NwaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoKTtcblxuICAgICAgICAgICAgdmFyIGZvcm0gPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgaWYgKGZvcm0ubGVuZ3RoID4gMCkgIC8vIERpc2FibGUgYWxsIGZvcm0gaW5wdXRzIGlmIHNwaW5uZXIgZWxlbWVudCBpcyBpbiBhIGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybS5maW5kKCc6aW5wdXQnKTtcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAvLyBvciBhbGwgaW5wdXRzIGNvbnRhaW5lZCBpbiB0aGUgc3Bpbm5lciBlbGVtZW50IG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmV4dGVuZCggdGhpcy5lbGVtZW50LmZpbmQoJzppbnB1dCcpICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB3aWRnZXQgaW5zdGFuY2UgKGUuZy4gZWxlbWVudCBjcmVhdGlvbiwgYXBwbHkgdGhlbWluZywgYmluZCBldmVudHMgZXRjLilcbiAgICAgICAgX2NyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FwcGVuZGluZycsIHdpZGdldE5hbWUsICdpbnN0YW5jZSB0bycsIHRoaXMuZWxlbWVudCwgJzonKTtcbiAgICAgICAgICAgIHRoaXMuX2dldERhdGFPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIgPSB0aGlzLl90ZW1wbGF0ZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5zcGlubmVyKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodGhpcy5zcGlubmVyKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxfdGl0bGUgPSB0aGlzLmVsZW1lbnQuYXR0cigndGl0bGUnKSB8fCBcIlwiO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzID0gdGhpcy5fZ2V0RGlzYWJsZVRhcmdldHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXN0cm95IHBsdWdpbiBpbnN0YW5jZSAgYW5kIGNsZWFuIHVwIG1vZGlmaWNhdGlvbnMgdGhlIHdpZGdldCBoYXMgbWFkZSB0byB0aGUgRE9NXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRGVzdHJveTonLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5yZW1vdmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgc3Bpbm5lciBmcm9tIGl0cyByZWxhdGl2ZSBsb2NhdGlvblxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24ocmVsYXRpdmVfcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuY3NzKHJlbGF0aXZlX3Bvcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2hvdywgSGlkZSwgYW5kIFRvZ2dsZSB0aGUgc3Bpbm5lci5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCd0aXRsZScsIHRoaXMub3JpZ2luYWxfdGl0bGUpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoICdoaWRkZW4nICwgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBzaG93OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyLnNob3coKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5zcGluX3RleHQpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCAnc2hvd24nICwgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGUgOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Bpbm5lci5pcyhcIjp2aXNpYmxlXCIpKSB0aGlzLmhpZGUoZXZlbnQpOyBlbHNlIHRoaXMuc2hvdyhldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQoc2VsZWN0b3JzLmFwcGVuZCkuc3Bpbm5lcigpO1xuXG59KSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7IiwiLyoqXG4gKiBCb290c3RyYXAgRXh0cmEgVXRpbGl0aWVzXG4gKiAgIC4uLiBvciwgdGhpbmdzIHlvdSBjYW4ndCBiZWxpZXZlIGFyZSBub3QgaW5jbHVkZWQgb3V0LW9mLXRoZS1ib3ggd2l0aCBKU1xuICpcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4MjM0MzE3LzE5OTM1MjVcblN0cmluZy5wcm90b3R5cGUuZm9ybWF0VW5pY29ybiA9IFN0cmluZy5wcm90b3R5cGUuZm9ybWF0VW5pY29ybiB8fFxuZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHQgPSB0eXBlb2YgYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgYXJncyA9IChcInN0cmluZ1wiID09PSB0IHx8IFwibnVtYmVyXCIgPT09IHQpID9cbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGFyZ3MpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxce1wiICsga2V5ICsgXCJcXFxcfVwiLCBcImdpXCIpLCBhcmdzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblN0cmluZy5wcm90b3R5cGUuYXNUZW1wbGF0ZSA9IFN0cmluZy5wcm90b3R5cGUuYXNUZW1wbGF0ZSB8fFxuZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5mb3JtYXRVbmljb3JuKGFyZ3MpO1xuICAgIH07XG59O1xuXG4vLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJvcGVydHksIGVsOm5hbWUsIGZvciBlYWNoIGVsIGluIGV4dGVuc2lvbnMsIHdoZXJlIG5hbWUgPSBwcmUgKyB0aGlzICsgc2VwICsgZWxcblN0cmluZy5wcm90b3R5cGUuYnVpbGROYW1lc01hcCA9IFN0cmluZy5wcm90b3R5cGUuYnVpbGROYW1lc01hcCB8fFxuZnVuY3Rpb24gKGV4dGVudGlvbnMsIHByZSwgc2VwKSB7XG4gIHByZSA9IHByZSB8fCAnJztcbiAgc2VwID0gc2VwIHx8ICctJztcbiAgdmFyIGJhc2UgPSB0aGlzO1xuICBmdW5jdGlvbiBidWlsZChvYmosIGtleSkge1xuICAgIG9ialtrZXldID0gcHJlK2Jhc2Urc2VwK2tleTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBtYXAgPSBleHRlbnRpb25zLnJlZHVjZShidWlsZCwge30pO1xuICBtYXBbYmFzZV0gPSBwcmUrYmFzZTtcbiAgcmV0dXJuIG1hcDtcbn07XG5cblxuLy8gcmVwbGFjZSBqUXVlcnkuYWpheCB3aXRoIGEgZnVuY3Rpb24gdGhhdCBtb2NrcyBhIHN1Y2Nlc3NmdWwgQUpBWCByZXNwb25zZS5cbi8vIGNhbGwgYnNlQWpheE1vY2tTdWNjZXNzKCkgYmVmb3JlIHRlc3RpbmcuICBUbyBEbzogIHVzZSBwcm9wZXIgdGVzdGluZyBmcmFtZXdvcmsgKGplc3QpICsgaHR0cDovL3Npbm9uanMub3JnLyN0ZXN0aW5nLWFqYXhcbmJzZUFqYXhNb2NrU3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICQuYWpheCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgYXJncy5iZWZvcmVTZW5kKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2FsbCBhamF4OlwiLCBhcmdzKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFyZ3Muc3VjY2Vzcyh7bWVzc2FnZSA6ICdNb2NrIEFKQVggY2FsbCAoc3VjY2VzcykuJ30pO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFyZ3MuY29tcGxldGUoKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgfVxufTsiXX0=
