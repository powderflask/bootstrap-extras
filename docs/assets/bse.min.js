(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * AJAX Delete It Component (v0.1): ajax_delete.js
 *   -- simple delete request via ajax.
 *
 *   Dependencies:  Bootstrap + JQuery + spinner
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './spinner');
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.ajax_delete',
        widgetClass = 'bse-ajax-delete',
        selectors = widgetClass.buildNamesMap(['it', 'control', 'target'], '.');

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            url: false,      // required option, can be set with data-url attribute on element
            method: 'DELETE',
            confirmation_message: "Confirm delete?  This action can NOT be undone.",  // set to false to disable confirmation

            // event callbacks (ajax event callbacks also trigger)
            deleteIt: null   // called just before delete request is made - return false to prevent default action
        },

        // Configure the widget control and target
        _configureControls : function() {
            this.control = this.element.find(selectors.control);
            this.options.url = this.options.url || this.control.attr('href');
            this.control.spinner({ disable_on_spin: true } );
            this.spinner = this.control.spinner('instance');
            this.target = this.element.find(selectors.target);
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;

            this.element.click( function (event) {
                event.preventDefault();
                self._deleteIt(event);
            });

            this.options.ajax_success = function() {
                console.log("Ajax delete success");
                self.element.hide();
            }
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this._configureControls();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log("Destroy: ", this.element);
            this.element.off('click');
        },

        _confirmDelete: function ( event ) {
            return !this.options.confirmation_message ||
                   confirm(this.options.confirmation_message);
        },

        _deleteIt: function ( event ) {
            if (this._confirmDelete()) {
                // allow user to augment or override default save logic
                var go = this._trigger( 'deleteIt', event );
                if ( go && this.options.url ) {
                    this._ajaxDelete(this.element, this.options);
                }
            }
        }
    });

    $(selectors['it']).ajax_delete();

})( jQuery, window, document );


},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5,"./spinner":9,"./util":11}],2:[function(require,module,exports){
/**
 * AJAX Save This Component (v0.1): ajax_save.js
 *   -- simple form sumbit via ajax.
 *
 *   Dependencies:  Bootstrap + JQuery + spinner
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './spinner');
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.ajax_save',
        widgetClass = 'bse-ajax-save',
        selectors = widgetClass.buildNamesMap(['this'], '.');

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            action: false,
            method: 'POST',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null   // called just before save request made - return false to prevent default action
        },

        // Configure the widget controls (edit icon and form elements)
        _configureControls : function() {
            this.form = this.element;
            this.form.spinner( { disable_on_spin: true } );
            this.spinner = this.form.spinner('instance');
            this.options.action = this.options.action || this.form.attr('action');
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;

            this.element.submit( function (event) {
                event.preventDefault();
                self._saveForm(event);
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this._configureControls();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log("Destroy: ", this.element);
            this.element.off('submit');
            // TO DO: put form back from whence it came?
        },

        _saveForm: function ( event ) {
            // allow user to augment or override default save logic
            var go = this._trigger( 'saveForm', event, { form_data: this.form.serialize() });
            if ( go && this.options.action ) {
                this._ajaxSubmitForm(this.form, this.options);
            }
        }
    });

    $(selectors['this']).ajax_save();

})( jQuery, window, document );


},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5,"./spinner":9,"./util":11}],3:[function(require,module,exports){
/**
 * Table Column Collapse (v0.1): col_collapse.js
 *   -- Collapse / Expand table columns by clicking on a cc-control.
 *   -- Demo: https://jsfiddle.net/powderflask/gd7ct85q/
 *   Use data-controls attribute on control to specify class of cc-target elements to collapse.
 *   Use data-controls='all' to control all cc-target elements
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.col_collapse',
        widgetClass = 'bse-col-collapse',
        classes = widgetClass.buildNamesMap(['collapsed', 'icon']),
        selectors = widgetClass.buildNamesMap(['collapsed', 'icon', 'add', 'controlAll', 'control', 'controlLabel'], '.'),

        markup = {
            expand_icon: ['<span>', {'class': classes.icon, 'aria-hidden': 'true'}],
        };

        // helpers
        expand = function(el){
            el.removeClass(classes.collapsed);
        };
        collapse = function(el){
            el.addClass(classes.collapsed);
        };
        toggleCollapsed = function(el) {
            el.toggleClass(classes.collapsed);
        };
        isCollapsed = function(el) {
            return el.hasClass(classes.collapsed);
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            control_title: 'Expand/Collapse Column',
            controlAll_title: 'Expand/Collapse All',
            controlAll_labels: {true: 'Expand All', false: 'Collapse All'},  // null or false to leave default
            icon_class: 'glyphicon glyphicon-resize-full bse-rotate-45',

            // event callbacks
            collapsed: null,
            expanded: null
        },

        // Configure and return the widget controls
        _configureControls : function() {
            var expand_icon = $.apply(this, markup.expand_icon).addClass(this.options.icon_class),
                col_controls = this.element.find(selectors.control),
                global_controls = this.element.find(selectors.controlAll);

            col_controls.append(expand_icon.clone())
                        .attr('title', this.options.control_title);
            global_controls.prepend(expand_icon.clone())
                           .attr('title', this.options.controlAll_title);
            collapse(global_controls);  // Assume initial state for global control is Expand All?
            global_controls.data('controls', col_controls);
            return {
                col : col_controls,
                global : global_controls
            };
        },

        // Configure the collapse targets for each control -- i.e., td elements in the same column
        _configureTargets : function(col_controls) {
            var table = this.element.is('table')?this.element:this.element.find('table')[0]
            table.addClass(widgetClass);
            // For each control, get all targets from its table column ( http://jsfiddle.net/8XSLF/ )
            $.each(col_controls, function(idx, val) {
                var control = $(this),
                    colNumber = control.parent("tr").children().index(control),
                    rows = table.find('> tbody > tr'),
                    targets = rows.find('td:nth-child(' + (colNumber + 1) + ')').add(control);
                if ( isCollapsed(control) ) {
                    collapse(targets);
                }
                control.data('targets', targets);
            });
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;
            this.controls.col.click( function(event) {
                self.toggleTargets($(this), event);
            });
            this.controls.global.click( function(event) {
                var control = $(this);
                expandAll = isCollapsed(control);
                $.each(self.controls.col, function() {
                    expandAll ? self.expandTargets($(this), event):self.collapseTargets($(this), event);
                });

                // optionally, change control's label
                toggleCollapsed(control);
                if (self.options.controlAll_labels) {
                    var label = control.find(selectors.controlLabel);
                    label.html(self.options.controlAll_labels[isCollapsed(control)]);
                }

            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log('Create ', widgetName, 'instance for', this.element);
            this._getDataOptions(); // if widget recognizes data-* options in markup
            this.controls = this._configureControls();
            this._configureTargets(this.controls.col);
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log('Destroy:', this);
            $(selectors.collapsed).removeClass(classes.collapsed);
            $(selectors.icon).remove();
            this.controls.col.attr('title', '').off('click');
            this.controls.global.attr('title', '').off('click');
            this.controls.col.data('targets', null);
            this.controls.global.data('controls', null);
        },

        // Public methods
        expandTargets : function(control, event) {
            var targets = control.data('targets');
            expand(targets);
            this._trigger( 'expanded', event, { control:control, targets:targets });
        },
        collapseTargets : function(control, event) {
            var targets = control.data('targets');
            collapse(targets);
            this._trigger( 'collapsed', event, { control:control, targets:targets });
        },
        toggleTargets : function(control, event) {
            isCollapsed(control) ? this.expandTargets(control, event) : this.collapseTargets(control, event);
        }
    });

    $(selectors.add).col_collapse();

})( jQuery, window, document );
},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5,"./util":11}],4:[function(require,module,exports){
/**
 * Edit This Component (v0.1): edit-this.js
 *   -- toggle display value with edit form for the value
 *   -- optionally, AJAX save edited form.
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.edit_this',
        widgetClass = 'bse-edit-this',
        classes = widgetClass.buildNamesMap(['icon', 'content']),
        selectors = widgetClass.buildNamesMap(['content'], '.'),

        markup = {
            edit_icon: ['<span>', {'class': classes.icon, 'aria-hidden': 'true'}]
         };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            action: false,
            method: 'POST',
            icon_class: 'glyphicon glyphicon-edit',
            icon_title: 'Edit this',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null,   // called when range_input is changed, before saving - return false to prevent default action
            showForm: null,   // called when form is shown
            hideForm: null    // called when form is hidden
        },

        // Update the content area from the current form value.
        _updateContent : function() {
            this.content.html(this.form_controls.val());
            this.content.append(this.edit_icon);
        },

        // Configure the widget controls (edit icon and form elements)
        _configureControls : function() {
            this.content = this.element.find(selectors.content);
            this.edit_icon = $.apply(this, markup.edit_icon)
                              .addClass(this.options.icon_class)
                              .attr('title', this.options.icon_title);
            this.content.append(this.edit_icon);

            // And the form...
            var form_id = this.element.data('form_id');
            this.form = $('#'+form_id);
            // Configure optional Ajax save with callback to hide the form on successful requests.
            this.form.ajax_save( $.extend(this.options, {ajax_success:this.hideForm.bind(this)}) );

            // ... move form to edit-this panel ...
            this.form_controls = this.form.find( ':input' );
            this.element.append(this.form.hide());
        },

        // is the target element part of the widget element?
        _contains : function(target) {
            return target.closest(this.element).length > 0;
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this;

            this.content.on('click', function (event) {
                event.preventDefault();
                self.showForm(event);
                self.form_controls[0].focus();
            });
            // hide form on clicks that are not within the element.
            $('body').click(function(event) {
                if (!self._contains($(event.target))) {
                    self.hideForm(event);
                }
            });

            this.form.on('change', function (event) {
                event.preventDefault();
                self._updateContent();
                self.form.submit();
                self.hideForm(event);
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this._configureControls();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log("Destroy: ", this.element);
            this.edit_icon.remove();
            this.hideForm();
            this.content.off('click');
            // TO DO: put form back from whence it came?
        },

        // Public methods
        showForm : function(event) {
            this.content.hide();
            this.form.show();
            this._trigger( 'showForm', event);
        },
        hideForm : function(event) {
            this.form.hide();
            this.content.show();
            this._trigger( 'hideForm', event);
        },
        isFormVisible: function() {
            return this.form.is(":visible");
        },
        toggleForm : function(event) {
            this.isFormVisible() ? this.showForm(event) : this.hideForm(event);
        }
    });

    $(selectors[widgetClass]).edit_this();

})( jQuery, window, document );


},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5,"./util":11}],5:[function(require,module,exports){
/**
 * Extensions for jQuery UI Widget Factory
 *    - _getDataOptions:  load options from data-option attributes in element's markup
 *    - _ajaxConfig
 *
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require( './jquery-ui-widget');
require( './util');

(function( $, window, document, undefined ) {

    const ajax_error_template =
        '<div class="alert alert-warning alert-dismissible" role="alert">' +
            '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' +
                '<span aria-hidden="true">&times;</span>' +
            '</button>' +
            'Oops! We encountered an error processing your request: {textStatus}' +
            '<br>Refresh page and try again?' +
        '</div>';

    var WidgetExtensionsMixin = {
        // Load any data- attribute options from the element's tag
        _getDataOptions : function() {
            var data_opts = this.element.data();
            opts = this.options;
            Object.keys(data_opts).forEach(function(key) {
                if (key in opts) {
                    opts[key] = data_opts[key];
                }
            });
        },

       /*
         * Standardized jQuery.ajax calls with default behaviours + triggers for BSE widgets
         *   E.g., this.ajax_submit_form({ optional_ajax_settings_or_overrides })
         *   Adds an optional callback and trigger for each local Ajax Event.
         */

        // Add ajax trigger events to this widget's options
        _ajaxConfig : function() {
             // Events triggered by ajax calls, used to extend widget options
            const ajax_event_options= {
                ajax_beforeSend: null,
                ajax_success: null,
                ajax_error: null,
                ajax_complete: null
            };
            this.options = $.extend({}, ajax_event_options, this.options);
        },


        // Submit this.form by ajax, with an optional this.spinner to display while loading
        _ajaxSubmitForm : function(form, settings) {
            var args = Object.create(settings),
                form_data = form.serialize() || "",
                extra_data = settings.data || "";
            args.data = form_data + extra_data;
            args.method = settings.method || form.attr('method') || 'POST';
            args.url = settings.action || settings.url || form.attr('action');
            console.assert(args.url, "BSE ajaxSubmitForm Error: a url or form action option must be supplied.");

            this._ajaxRequest(form, args);
        },

        // Make a DELETE ajax request for this.element, with an optional this.spinner to display while loading
        _ajaxDelete : function(target, settings) {
            var args = Object.create(settings);
            args.method = settings.method || 'DELETE';
            args.url = settings.url || settings.action;
            console.assert(args.url, "BSE ajaxDelete Error: a url must be supplied.");

            console.log("Make Ajax delete request", args);
            this._ajaxRequest(target, args);
        },

        _ajaxRequest: function(target, args) {
            var self = this,
                ajax_events = {
                    beforeSend: function () {
                        if (self.spinner) self.spinner.show();
                        self._trigger('ajax_beforeSend', null, {args: args});
                    },
                    success: function (json, textStatus, xhr) {
                        if (json.message) target.after(json.message);
                        self._trigger('ajax_success', null, {args: arguments});
                    },
                    error: function (xhr, textStatus, errorThrown) {
                        target.after($(ajax_error_template.formatUnicorn({textStatus: textStatus})));
                        console.log(xhr.status + ": " + xhr.responseText);
                        console.log(errorThrown);
                        self._trigger('ajax_error', null, {args: args, xhr_args: arguments});
                    },
                    complete: function (xhr, textStatus) {
                        if (self.spinner) self.spinner.hide();
                        self._trigger('ajax_complete', null, {args: args, xhr_args: arguments});
                    }
                };

            $.ajax($.extend(ajax_events, args));
        }
    };

    if ('Widget' in $) {
        Object.assign($.Widget.prototype, WidgetExtensionsMixin);
    }
})(jQuery, window, document);

},{"./jquery-ui-widget":6,"./util":11}],6:[function(require,module,exports){
/*! jQuery UI - v1.12.1 - 2018-06-05
* http://jqueryui.com
* Includes: widget.js, position.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;




}));
},{}],7:[function(require,module,exports){
/**
 * Bootstrap Extras (v0.1): main.js
 *   -- Collate all component scripts via Broswerify https://www.npmjs.com/package/browserify
 *
 *   External Dependencies:  Bootstrap 3 + JQuery 2+
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require('./ajax_delete');
require('./ajax_save');
require('./edit-this');
require('./col_collapse');
require('./progress_report');
require('./spinner');
require('./toggle_that');

},{"./ajax_delete":1,"./ajax_save":2,"./col_collapse":3,"./edit-this":4,"./progress_report":8,"./spinner":9,"./toggle_that":10}],8:[function(require,module,exports){
/**
 * Progress Report Component (v0.1): progress_report.js
 *   -- a Bootstrap Progress Bar with an interactive range input
 *   -- AJAX save selected value using standard HMTL form.
 *
 *   Dependencies:  Bootstrap + JQuery + spinner
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './spinner');
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');
require( './util' );

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.progress_report',
        widgetClass = 'bse-progress-report',
        classes = widgetClass.buildNamesMap(['panel', 'form', 'value']),
        selectors = widgetClass.buildNamesMap([], '.'),

        markup = {
            panel : ['<div>', {'class': classes.panel}],
            form : ['<form>', {'class': classes.form}],
            input : ['<input>', {type:'range', 'class': widgetClass, name:classes.value, required:''}]
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            min: 0,
            max: 100,
            action: false,
            method: 'POST',

            // event callbacks (ajax event callbacks also trigger)
            saveForm: null   // called when range_input is changed, before saving - return false to prevent default action
        },

        // Template node for the widget
        _template : function() {
            this.progress = this.element.clone();
            this.progress_bar = this.progress.find('.progress-bar');
            this.value = this.progress_bar.attr('aria-valuenow');
            this.range_input = $.apply(this, markup.input);  // $(...markup.input)
            this.form = $.apply(this, markup.form).append(this.range_input);
            this.panel = $.apply(this, markup.panel).append(this.progress).append(this.form);

            // Configure optional Ajax save with callback to hide form on successful requests.
            this.form.ajax_save( $.extend(this.options, {ajax_success:this.form.hide.bind(this.form)}) );
            this.range_input.attr('min', this.options.min).attr('max', this.options.max);
            this.range_input.val(this.value);

            return this.panel;
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            var self = this,
                spinner = self.form.spinner('instance');  // ouch - tight coupling to ajax-save here.

            this.range_input.on('input', function(event) {
                self.value = self.range_input.val() || 0;
                self.progress_bar.text(self.value + '% Complete');
                self.progress_bar.css( 'width', self.value+'%');
                spinner.position( {top: '-1em', left:(self.value-1)+'%'} );
            });

            this.progress.on('click', function (event) {
                event.preventDefault();
                self.form.show();
                self.range_input.focus();
                self.range_input.blur(function (event) {
                   self.form.hide();
                });
            });

            this.form.on('change', function (event) {
                event.preventDefault();
                self.form.submit();
                self.form.hide();
            });
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log("Create ", widgetName, " instance for", this.element);
            this._ajaxConfig();
            this._getDataOptions();
            this.element.after(this._template());
            this.element.hide();
            this._configureEventHandlers();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            console.log("Destroy: ", this.panel);
            this.panel.remove();
            this.element.show();
        }
    });

    $(selectors[widgetClass]).progress_report();

})( jQuery, window, document );


},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5,"./spinner":9,"./util":11}],9:[function(require,module,exports){
/**
 * AJAX Loading Spinner (v0.1): spinner.js
 *   -- a JQuery plugin spinner to signal asyn request in-progress
 *   -- show / hide spinner can optionally control enable/disable widget's element
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.spinner',
        widgetClass = 'bse-spinner',
        selectors = {
            'append' : '.'+widgetClass+'-append'
        },
        markup = {
            spinner: ['<span>', {'class': widgetClass}]
        };

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            spin_text: 'Saving...',  // title and accessibility text for spinner
            disable_on_spin: false,  // set to true to disable all :inputs in the parent element when spinner shows

            // event callbacks
            hidden: null,   // triggers when spinner is hidden
            shown: null     // triggers when spinner is shown
        },

        // Template node for the widget
        _template : function() {
            return $.apply(this, markup.spinner).hide().html(this.options.spin_text);
        },

        _getDisableTargets : function() {
            if (!this.options.disable_on_spin)
                return $();

            var form = this.element.closest('form');
            if (form.length > 0)  // Disable all form inputs if spinner element is in a form
                return form.find(':input');
            else                  // or all inputs contained in the spinner element otherwise.
                return this.element.extend( this.element.find(':input') );
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log('Appending', widgetName, 'instance to', this.element, ':');
            this._getDataOptions();
            this.spinner = this._template();
            // console.log(this.spinner);
            this.element.append(this.spinner);
            this.original_title = this.element.attr('title') || "";
            this.targets = this._getDisableTargets();
        },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log('Destroy:', this);
            this.spinner.remove();
        },

        // Position the spinner from its relative location
        position: function(relative_pos) {
            this.spinner.css(relative_pos);
        },

        // Show, Hide, and Toggle the spinner.
        hide: function(event) {
            this.element.attr('title', this.original_title);
            this.targets.prop('disabled', false);
            this.spinner.hide();
            this._trigger( 'hidden' , event);
        },
        show: function(event) {
            this.spinner.show();
            this.element.attr('title', this.options.spin_text);
            this.targets.prop('disabled', true);
            this._trigger( 'shown' , event);
        },
        toggle : function(event) {
            if (this.spinner.is(":visible")) this.hide(event); else this.show(event);
        }
    });

    $(selectors.append).spinner();

})( jQuery, window, document );
},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5}],10:[function(require,module,exports){
/**
 * Toggle That (v0.1): toggle_that.js
 *   -- toggle a collection of elements from a set of controls
 *
 *   Dependencies:  Bootstrap + JQuery
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */
require( './jquery-ui-widget');
require( './jquery-ui-widget-extensions');

;(function( $, window, document, undefined ) {

    var widgetName = 'bse.toggle_that',
        widgetClass = 'bse-toggle-that',
        selectors = widgetClass.buildNamesMap(['control', 'target'], '.');

    $.widget( widgetName, {

        // Options to be used as defaults
        options: {
            initToggle: true,   // false to NOT toggle elements during initialization

            // event callbacks (ajax events added during create)
            toggled: null
        },

        // Events handled by this widget
        _configureEventHandlers : function() {
            this.control.click(this.toggle.bind(this));
        },

        // Initialize widget instance (e.g. element creation, apply theming, bind events etc.)
        _create: function () {
            // console.log('Create ', widgetName, 'instance for', this.element);
            this.control = this.element.find(selectors.control);
            this.target = this.element.find(selectors.target);
            this._configureEventHandlers();
            if (this.options.initToggle)
                this.toggle();
         },

        // Destroy plugin instance  and clean up modifications the widget has made to the DOM
        _destroy: function () {
            // console.log('Destroy:', this);
            this.control.off('click');
        },

        // Public methods
        toggle: function(event) {
           this.target.toggle();
           this._trigger( 'toggled' , event);
        }
    });

    $(selectors[widgetClass]).toggle_that();

})( jQuery, window, document );
},{"./jquery-ui-widget":6,"./jquery-ui-widget-extensions":5}],11:[function(require,module,exports){
/**
 * Bootstrap Extra Utilities
 *   ... or, things you can't believe are not included out-of-the-box with JS
 *
 *   MIT Open-source License (https://github.com/powderflask/bootstrap_extras/blob/master/LICENSE)
 */

// https://stackoverflow.com/a/18234317/1993525
String.prototype.formatUnicorn = String.prototype.formatUnicorn ||
function () {
    "use strict";
    var str = this.toString();
    if (arguments.length) {
        var t = typeof arguments[0];
        var key;
        var args = ("string" === t || "number" === t) ?
            Array.prototype.slice.call(arguments)
            : arguments[0];

        for (key in args) {
            str = str.replace(new RegExp("\\{" + key + "\\}", "gi"), args[key]);
        }
    }

    return str;
};

String.prototype.asTemplate = String.prototype.asTemplate ||
function () {
    "use strict";
    var template = this.toString();

    return function(args) {
        return template.formatUnicorn(args);
    };
};

// Return an object with property, el:name, for each el in extensions, where name = pre + this + sep + el
String.prototype.buildNamesMap = String.prototype.buildNamesMap ||
function (extentions, pre, sep) {
  pre = pre || '';
  sep = sep || '-';
  var base = this;
  function build(obj, key) {
    obj[key] = pre+base+sep+key;
    return obj;
  }
  var map = extentions.reduce(build, {});
  map[base] = pre+base;
  return map;
};


// replace jQuery.ajax with a function that mocks a successful AJAX response.
// call bseAjaxMockSuccess() before testing.  To Do:  use proper testing framework (jest) + http://sinonjs.org/#testing-ajax
bseAjaxMockSuccess = function() {
    $.ajax = function(args) {
        args.beforeSend();
        console.log("call ajax:", args);
        setTimeout(function() {
            args.success({message : 'Mock AJAX call (success).'});
        }, 3000);
        setTimeout(function() {
            args.complete();
        }, 3000);
    }
};
},{}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL2FqYXhfZGVsZXRlLmpzIiwic2NyaXB0cy9hamF4X3NhdmUuanMiLCJzY3JpcHRzL2NvbF9jb2xsYXBzZS5qcyIsInNjcmlwdHMvZWRpdC10aGlzLmpzIiwic2NyaXB0cy9qcXVlcnktdWktd2lkZ2V0LWV4dGVuc2lvbnMuanMiLCJzY3JpcHRzL2pxdWVyeS11aS13aWRnZXQuanMiLCJzY3JpcHRzL21haW4uanMiLCJzY3JpcHRzL3Byb2dyZXNzX3JlcG9ydC5qcyIsInNjcmlwdHMvc3Bpbm5lci5qcyIsInNjcmlwdHMvdG9nZ2xlX3RoYXQuanMiLCJzY3JpcHRzL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNudENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqXG4gKiBBSkFYIERlbGV0ZSBJdCBDb21wb25lbnQgKHYwLjEpOiBhamF4X2RlbGV0ZS5qc1xuICogICAtLSBzaW1wbGUgZGVsZXRlIHJlcXVlc3QgdmlhIGFqYXguXG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnkgKyBzcGlubmVyXG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5yZXF1aXJlKCAnLi9zcGlubmVyJyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0Jyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoICcuL3V0aWwnICk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS5hamF4X2RlbGV0ZScsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1hamF4LWRlbGV0ZScsXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydpdCcsICdjb250cm9sJywgJ3RhcmdldCddLCAnLicpO1xuXG4gICAgJC53aWRnZXQoIHdpZGdldE5hbWUsIHtcblxuICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdXJsOiBmYWxzZSwgICAgICAvLyByZXF1aXJlZCBvcHRpb24sIGNhbiBiZSBzZXQgd2l0aCBkYXRhLXVybCBhdHRyaWJ1dGUgb24gZWxlbWVudFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbl9tZXNzYWdlOiBcIkNvbmZpcm0gZGVsZXRlPyAgVGhpcyBhY3Rpb24gY2FuIE5PVCBiZSB1bmRvbmUuXCIsICAvLyBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjb25maXJtYXRpb25cblxuICAgICAgICAgICAgLy8gZXZlbnQgY2FsbGJhY2tzIChhamF4IGV2ZW50IGNhbGxiYWNrcyBhbHNvIHRyaWdnZXIpXG4gICAgICAgICAgICBkZWxldGVJdDogbnVsbCAgIC8vIGNhbGxlZCBqdXN0IGJlZm9yZSBkZWxldGUgcmVxdWVzdCBpcyBtYWRlIC0gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb25maWd1cmUgdGhlIHdpZGdldCBjb250cm9sIGFuZCB0YXJnZXRcbiAgICAgICAgX2NvbmZpZ3VyZUNvbnRyb2xzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmVsZW1lbnQuZmluZChzZWxlY3RvcnMuY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudXJsID0gdGhpcy5vcHRpb25zLnVybCB8fCB0aGlzLmNvbnRyb2wuYXR0cignaHJlZicpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sLnNwaW5uZXIoeyBkaXNhYmxlX29uX3NwaW46IHRydWUgfSApO1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyID0gdGhpcy5jb250cm9sLnNwaW5uZXIoJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuZWxlbWVudC5maW5kKHNlbGVjdG9ycy50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV2ZW50cyBoYW5kbGVkIGJ5IHRoaXMgd2lkZ2V0XG4gICAgICAgIF9jb25maWd1cmVFdmVudEhhbmRsZXJzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGljayggZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWxldGVJdChldmVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFqYXhfc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWpheCBkZWxldGUgc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlIFwiLCB3aWRnZXROYW1lLCBcIiBpbnN0YW5jZSBmb3JcIiwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2FqYXhDb25maWcoKTtcbiAgICAgICAgICAgIHRoaXMuX2dldERhdGFPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmVDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlc3Ryb3kgcGx1Z2luIGluc3RhbmNlICBhbmQgY2xlYW4gdXAgbW9kaWZpY2F0aW9ucyB0aGUgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveTogXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub2ZmKCdjbGljaycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jb25maXJtRGVsZXRlOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuY29uZmlybWF0aW9uX21lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAgICBjb25maXJtKHRoaXMub3B0aW9ucy5jb25maXJtYXRpb25fbWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RlbGV0ZUl0OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbmZpcm1EZWxldGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHVzZXIgdG8gYXVnbWVudCBvciBvdmVycmlkZSBkZWZhdWx0IHNhdmUgbG9naWNcbiAgICAgICAgICAgICAgICB2YXIgZ28gPSB0aGlzLl90cmlnZ2VyKCAnZGVsZXRlSXQnLCBldmVudCApO1xuICAgICAgICAgICAgICAgIGlmICggZ28gJiYgdGhpcy5vcHRpb25zLnVybCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWpheERlbGV0ZSh0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9yc1snaXQnXSkuYWpheF9kZWxldGUoKTtcblxufSkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXG4iLCIvKipcbiAqIEFKQVggU2F2ZSBUaGlzIENvbXBvbmVudCAodjAuMSk6IGFqYXhfc2F2ZS5qc1xuICogICAtLSBzaW1wbGUgZm9ybSBzdW1iaXQgdmlhIGFqYXguXG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnkgKyBzcGlubmVyXG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5yZXF1aXJlKCAnLi9zcGlubmVyJyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0Jyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoICcuL3V0aWwnICk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS5hamF4X3NhdmUnLFxuICAgICAgICB3aWRnZXRDbGFzcyA9ICdic2UtYWpheC1zYXZlJyxcbiAgICAgICAgc2VsZWN0b3JzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ3RoaXMnXSwgJy4nKTtcblxuICAgICQud2lkZ2V0KCB3aWRnZXROYW1lLCB7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0byBiZSB1c2VkIGFzIGRlZmF1bHRzXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGFjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcblxuICAgICAgICAgICAgLy8gZXZlbnQgY2FsbGJhY2tzIChhamF4IGV2ZW50IGNhbGxiYWNrcyBhbHNvIHRyaWdnZXIpXG4gICAgICAgICAgICBzYXZlRm9ybTogbnVsbCAgIC8vIGNhbGxlZCBqdXN0IGJlZm9yZSBzYXZlIHJlcXVlc3QgbWFkZSAtIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHRoZSB3aWRnZXQgY29udHJvbHMgKGVkaXQgaWNvbiBhbmQgZm9ybSBlbGVtZW50cylcbiAgICAgICAgX2NvbmZpZ3VyZUNvbnRyb2xzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZvcm0uc3Bpbm5lciggeyBkaXNhYmxlX29uX3NwaW46IHRydWUgfSApO1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyID0gdGhpcy5mb3JtLnNwaW5uZXIoJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWN0aW9uID0gdGhpcy5vcHRpb25zLmFjdGlvbiB8fCB0aGlzLmZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXZlbnRzIGhhbmRsZWQgYnkgdGhpcyB3aWRnZXRcbiAgICAgICAgX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN1Ym1pdCggZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9zYXZlRm9ybShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdpZGdldCBpbnN0YW5jZSAoZS5nLiBlbGVtZW50IGNyZWF0aW9uLCBhcHBseSB0aGVtaW5nLCBiaW5kIGV2ZW50cyBldGMuKVxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNyZWF0ZSBcIiwgd2lkZ2V0TmFtZSwgXCIgaW5zdGFuY2UgZm9yXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9hamF4Q29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLl9nZXREYXRhT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXN0cm95IHBsdWdpbiBpbnN0YW5jZSAgYW5kIGNsZWFuIHVwIG1vZGlmaWNhdGlvbnMgdGhlIHdpZGdldCBoYXMgbWFkZSB0byB0aGUgRE9NXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRlc3Ryb3k6IFwiLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm9mZignc3VibWl0Jyk7XG4gICAgICAgICAgICAvLyBUTyBETzogcHV0IGZvcm0gYmFjayBmcm9tIHdoZW5jZSBpdCBjYW1lP1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zYXZlRm9ybTogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHVzZXIgdG8gYXVnbWVudCBvciBvdmVycmlkZSBkZWZhdWx0IHNhdmUgbG9naWNcbiAgICAgICAgICAgIHZhciBnbyA9IHRoaXMuX3RyaWdnZXIoICdzYXZlRm9ybScsIGV2ZW50LCB7IGZvcm1fZGF0YTogdGhpcy5mb3JtLnNlcmlhbGl6ZSgpIH0pO1xuICAgICAgICAgICAgaWYgKCBnbyAmJiB0aGlzLm9wdGlvbnMuYWN0aW9uICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FqYXhTdWJtaXRGb3JtKHRoaXMuZm9ybSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJChzZWxlY3RvcnNbJ3RoaXMnXSkuYWpheF9zYXZlKCk7XG5cbn0pKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblxuIiwiLyoqXG4gKiBUYWJsZSBDb2x1bW4gQ29sbGFwc2UgKHYwLjEpOiBjb2xfY29sbGFwc2UuanNcbiAqICAgLS0gQ29sbGFwc2UgLyBFeHBhbmQgdGFibGUgY29sdW1ucyBieSBjbGlja2luZyBvbiBhIGNjLWNvbnRyb2wuXG4gKiAgIC0tIERlbW86IGh0dHBzOi8vanNmaWRkbGUubmV0L3Bvd2RlcmZsYXNrL2dkN2N0ODVxL1xuICogICBVc2UgZGF0YS1jb250cm9scyBhdHRyaWJ1dGUgb24gY29udHJvbCB0byBzcGVjaWZ5IGNsYXNzIG9mIGNjLXRhcmdldCBlbGVtZW50cyB0byBjb2xsYXBzZS5cbiAqICAgVXNlIGRhdGEtY29udHJvbHM9J2FsbCcgdG8gY29udHJvbCBhbGwgY2MtdGFyZ2V0IGVsZW1lbnRzXG4gKlxuICogICBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgKyBKUXVlcnlcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSggJy4vdXRpbCcgKTtcblxuOyhmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4gICAgdmFyIHdpZGdldE5hbWUgPSAnYnNlLmNvbF9jb2xsYXBzZScsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1jb2wtY29sbGFwc2UnLFxuICAgICAgICBjbGFzc2VzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ2NvbGxhcHNlZCcsICdpY29uJ10pLFxuICAgICAgICBzZWxlY3RvcnMgPSB3aWRnZXRDbGFzcy5idWlsZE5hbWVzTWFwKFsnY29sbGFwc2VkJywgJ2ljb24nLCAnYWRkJywgJ2NvbnRyb2xBbGwnLCAnY29udHJvbCcsICdjb250cm9sTGFiZWwnXSwgJy4nKSxcblxuICAgICAgICBtYXJrdXAgPSB7XG4gICAgICAgICAgICBleHBhbmRfaWNvbjogWyc8c3Bhbj4nLCB7J2NsYXNzJzogY2xhc3Nlcy5pY29uLCAnYXJpYS1oaWRkZW4nOiAndHJ1ZSd9XSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBoZWxwZXJzXG4gICAgICAgIGV4cGFuZCA9IGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKGNsYXNzZXMuY29sbGFwc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29sbGFwc2UgPSBmdW5jdGlvbihlbCl7XG4gICAgICAgICAgICBlbC5hZGRDbGFzcyhjbGFzc2VzLmNvbGxhcHNlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRvZ2dsZUNvbGxhcHNlZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcyhjbGFzc2VzLmNvbGxhcHNlZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5oYXNDbGFzcyhjbGFzc2VzLmNvbGxhcHNlZCk7XG4gICAgICAgIH07XG5cbiAgICAkLndpZGdldCggd2lkZ2V0TmFtZSwge1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gYmUgdXNlZCBhcyBkZWZhdWx0c1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBjb250cm9sX3RpdGxlOiAnRXhwYW5kL0NvbGxhcHNlIENvbHVtbicsXG4gICAgICAgICAgICBjb250cm9sQWxsX3RpdGxlOiAnRXhwYW5kL0NvbGxhcHNlIEFsbCcsXG4gICAgICAgICAgICBjb250cm9sQWxsX2xhYmVsczoge3RydWU6ICdFeHBhbmQgQWxsJywgZmFsc2U6ICdDb2xsYXBzZSBBbGwnfSwgIC8vIG51bGwgb3IgZmFsc2UgdG8gbGVhdmUgZGVmYXVsdFxuICAgICAgICAgICAgaWNvbl9jbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLWZ1bGwgYnNlLXJvdGF0ZS00NScsXG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgY29sbGFwc2VkOiBudWxsLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb25maWd1cmUgYW5kIHJldHVybiB0aGUgd2lkZ2V0IGNvbnRyb2xzXG4gICAgICAgIF9jb25maWd1cmVDb250cm9scyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZF9pY29uID0gJC5hcHBseSh0aGlzLCBtYXJrdXAuZXhwYW5kX2ljb24pLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pY29uX2NsYXNzKSxcbiAgICAgICAgICAgICAgICBjb2xfY29udHJvbHMgPSB0aGlzLmVsZW1lbnQuZmluZChzZWxlY3RvcnMuY29udHJvbCksXG4gICAgICAgICAgICAgICAgZ2xvYmFsX2NvbnRyb2xzID0gdGhpcy5lbGVtZW50LmZpbmQoc2VsZWN0b3JzLmNvbnRyb2xBbGwpO1xuXG4gICAgICAgICAgICBjb2xfY29udHJvbHMuYXBwZW5kKGV4cGFuZF9pY29uLmNsb25lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCB0aGlzLm9wdGlvbnMuY29udHJvbF90aXRsZSk7XG4gICAgICAgICAgICBnbG9iYWxfY29udHJvbHMucHJlcGVuZChleHBhbmRfaWNvbi5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJywgdGhpcy5vcHRpb25zLmNvbnRyb2xBbGxfdGl0bGUpO1xuICAgICAgICAgICAgY29sbGFwc2UoZ2xvYmFsX2NvbnRyb2xzKTsgIC8vIEFzc3VtZSBpbml0aWFsIHN0YXRlIGZvciBnbG9iYWwgY29udHJvbCBpcyBFeHBhbmQgQWxsP1xuICAgICAgICAgICAgZ2xvYmFsX2NvbnRyb2xzLmRhdGEoJ2NvbnRyb2xzJywgY29sX2NvbnRyb2xzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sIDogY29sX2NvbnRyb2xzLFxuICAgICAgICAgICAgICAgIGdsb2JhbCA6IGdsb2JhbF9jb250cm9sc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDb25maWd1cmUgdGhlIGNvbGxhcHNlIHRhcmdldHMgZm9yIGVhY2ggY29udHJvbCAtLSBpLmUuLCB0ZCBlbGVtZW50cyBpbiB0aGUgc2FtZSBjb2x1bW5cbiAgICAgICAgX2NvbmZpZ3VyZVRhcmdldHMgOiBmdW5jdGlvbihjb2xfY29udHJvbHMpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHRoaXMuZWxlbWVudC5pcygndGFibGUnKT90aGlzLmVsZW1lbnQ6dGhpcy5lbGVtZW50LmZpbmQoJ3RhYmxlJylbMF1cbiAgICAgICAgICAgIHRhYmxlLmFkZENsYXNzKHdpZGdldENsYXNzKTtcbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbnRyb2wsIGdldCBhbGwgdGFyZ2V0cyBmcm9tIGl0cyB0YWJsZSBjb2x1bW4gKCBodHRwOi8vanNmaWRkbGUubmV0LzhYU0xGLyApXG4gICAgICAgICAgICAkLmVhY2goY29sX2NvbnRyb2xzLCBmdW5jdGlvbihpZHgsIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgY29sTnVtYmVyID0gY29udHJvbC5wYXJlbnQoXCJ0clwiKS5jaGlsZHJlbigpLmluZGV4KGNvbnRyb2wpLFxuICAgICAgICAgICAgICAgICAgICByb3dzID0gdGFibGUuZmluZCgnPiB0Ym9keSA+IHRyJyksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMgPSByb3dzLmZpbmQoJ3RkOm50aC1jaGlsZCgnICsgKGNvbE51bWJlciArIDEpICsgJyknKS5hZGQoY29udHJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0NvbGxhcHNlZChjb250cm9sKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGFwc2UodGFyZ2V0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZGF0YSgndGFyZ2V0cycsIHRhcmdldHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXZlbnRzIGhhbmRsZWQgYnkgdGhpcyB3aWRnZXRcbiAgICAgICAgX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuY29sLmNsaWNrKCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYudG9nZ2xlVGFyZ2V0cygkKHRoaXMpLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZ2xvYmFsLmNsaWNrKCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICBleHBhbmRBbGwgPSBpc0NvbGxhcHNlZChjb250cm9sKTtcbiAgICAgICAgICAgICAgICAkLmVhY2goc2VsZi5jb250cm9scy5jb2wsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRBbGwgPyBzZWxmLmV4cGFuZFRhcmdldHMoJCh0aGlzKSwgZXZlbnQpOnNlbGYuY29sbGFwc2VUYXJnZXRzKCQodGhpcyksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsbHksIGNoYW5nZSBjb250cm9sJ3MgbGFiZWxcbiAgICAgICAgICAgICAgICB0b2dnbGVDb2xsYXBzZWQoY29udHJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb250cm9sQWxsX2xhYmVscykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBjb250cm9sLmZpbmQoc2VsZWN0b3JzLmNvbnRyb2xMYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmh0bWwoc2VsZi5vcHRpb25zLmNvbnRyb2xBbGxfbGFiZWxzW2lzQ29sbGFwc2VkKGNvbnRyb2wpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdpZGdldCBpbnN0YW5jZSAoZS5nLiBlbGVtZW50IGNyZWF0aW9uLCBhcHBseSB0aGVtaW5nLCBiaW5kIGV2ZW50cyBldGMuKVxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3JlYXRlICcsIHdpZGdldE5hbWUsICdpbnN0YW5jZSBmb3InLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fZ2V0RGF0YU9wdGlvbnMoKTsgLy8gaWYgd2lkZ2V0IHJlY29nbml6ZXMgZGF0YS0qIG9wdGlvbnMgaW4gbWFya3VwXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5fY29uZmlndXJlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZVRhcmdldHModGhpcy5jb250cm9scy5jb2wpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlc3Ryb3kgcGx1Z2luIGluc3RhbmNlICBhbmQgY2xlYW4gdXAgbW9kaWZpY2F0aW9ucyB0aGUgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdEZXN0cm95OicsIHRoaXMpO1xuICAgICAgICAgICAgJChzZWxlY3RvcnMuY29sbGFwc2VkKS5yZW1vdmVDbGFzcyhjbGFzc2VzLmNvbGxhcHNlZCk7XG4gICAgICAgICAgICAkKHNlbGVjdG9ycy5pY29uKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuY29sLmF0dHIoJ3RpdGxlJywgJycpLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZ2xvYmFsLmF0dHIoJ3RpdGxlJywgJycpLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuY29sLmRhdGEoJ3RhcmdldHMnLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZ2xvYmFsLmRhdGEoJ2NvbnRyb2xzJywgbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUHVibGljIG1ldGhvZHNcbiAgICAgICAgZXhwYW5kVGFyZ2V0cyA6IGZ1bmN0aW9uKGNvbnRyb2wsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGNvbnRyb2wuZGF0YSgndGFyZ2V0cycpO1xuICAgICAgICAgICAgZXhwYW5kKHRhcmdldHMpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlciggJ2V4cGFuZGVkJywgZXZlbnQsIHsgY29udHJvbDpjb250cm9sLCB0YXJnZXRzOnRhcmdldHMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhcHNlVGFyZ2V0cyA6IGZ1bmN0aW9uKGNvbnRyb2wsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGNvbnRyb2wuZGF0YSgndGFyZ2V0cycpO1xuICAgICAgICAgICAgY29sbGFwc2UodGFyZ2V0cyk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCAnY29sbGFwc2VkJywgZXZlbnQsIHsgY29udHJvbDpjb250cm9sLCB0YXJnZXRzOnRhcmdldHMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVRhcmdldHMgOiBmdW5jdGlvbihjb250cm9sLCBldmVudCkge1xuICAgICAgICAgICAgaXNDb2xsYXBzZWQoY29udHJvbCkgPyB0aGlzLmV4cGFuZFRhcmdldHMoY29udHJvbCwgZXZlbnQpIDogdGhpcy5jb2xsYXBzZVRhcmdldHMoY29udHJvbCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9ycy5hZGQpLmNvbF9jb2xsYXBzZSgpO1xuXG59KSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7IiwiLyoqXG4gKiBFZGl0IFRoaXMgQ29tcG9uZW50ICh2MC4xKTogZWRpdC10aGlzLmpzXG4gKiAgIC0tIHRvZ2dsZSBkaXNwbGF5IHZhbHVlIHdpdGggZWRpdCBmb3JtIGZvciB0aGUgdmFsdWVcbiAqICAgLS0gb3B0aW9uYWxseSwgQUpBWCBzYXZlIGVkaXRlZCBmb3JtLlxuICpcbiAqICAgRGVwZW5kZW5jaWVzOiAgQm9vdHN0cmFwICsgSlF1ZXJ5XG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0Jyk7XG5yZXF1aXJlKCAnLi9qcXVlcnktdWktd2lkZ2V0LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoICcuL3V0aWwnICk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS5lZGl0X3RoaXMnLFxuICAgICAgICB3aWRnZXRDbGFzcyA9ICdic2UtZWRpdC10aGlzJyxcbiAgICAgICAgY2xhc3NlcyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydpY29uJywgJ2NvbnRlbnQnXSksXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydjb250ZW50J10sICcuJyksXG5cbiAgICAgICAgbWFya3VwID0ge1xuICAgICAgICAgICAgZWRpdF9pY29uOiBbJzxzcGFuPicsIHsnY2xhc3MnOiBjbGFzc2VzLmljb24sICdhcmlhLWhpZGRlbic6ICd0cnVlJ31dXG4gICAgICAgICB9O1xuXG4gICAgJC53aWRnZXQoIHdpZGdldE5hbWUsIHtcblxuICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaWNvbl9jbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tZWRpdCcsXG4gICAgICAgICAgICBpY29uX3RpdGxlOiAnRWRpdCB0aGlzJyxcblxuICAgICAgICAgICAgLy8gZXZlbnQgY2FsbGJhY2tzIChhamF4IGV2ZW50IGNhbGxiYWNrcyBhbHNvIHRyaWdnZXIpXG4gICAgICAgICAgICBzYXZlRm9ybTogbnVsbCwgICAvLyBjYWxsZWQgd2hlbiByYW5nZV9pbnB1dCBpcyBjaGFuZ2VkLCBiZWZvcmUgc2F2aW5nIC0gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICAgIHNob3dGb3JtOiBudWxsLCAgIC8vIGNhbGxlZCB3aGVuIGZvcm0gaXMgc2hvd25cbiAgICAgICAgICAgIGhpZGVGb3JtOiBudWxsICAgIC8vIGNhbGxlZCB3aGVuIGZvcm0gaXMgaGlkZGVuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IGFyZWEgZnJvbSB0aGUgY3VycmVudCBmb3JtIHZhbHVlLlxuICAgICAgICBfdXBkYXRlQ29udGVudCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50Lmh0bWwodGhpcy5mb3JtX2NvbnRyb2xzLnZhbCgpKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5hcHBlbmQodGhpcy5lZGl0X2ljb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgd2lkZ2V0IGNvbnRyb2xzIChlZGl0IGljb24gYW5kIGZvcm0gZWxlbWVudHMpXG4gICAgICAgIF9jb25maWd1cmVDb250cm9scyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5lbGVtZW50LmZpbmQoc2VsZWN0b3JzLmNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5lZGl0X2ljb24gPSAkLmFwcGx5KHRoaXMsIG1hcmt1cC5lZGl0X2ljb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmljb25fY2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCB0aGlzLm9wdGlvbnMuaWNvbl90aXRsZSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kKHRoaXMuZWRpdF9pY29uKTtcblxuICAgICAgICAgICAgLy8gQW5kIHRoZSBmb3JtLi4uXG4gICAgICAgICAgICB2YXIgZm9ybV9pZCA9IHRoaXMuZWxlbWVudC5kYXRhKCdmb3JtX2lkJyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSAkKCcjJytmb3JtX2lkKTtcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyZSBvcHRpb25hbCBBamF4IHNhdmUgd2l0aCBjYWxsYmFjayB0byBoaWRlIHRoZSBmb3JtIG9uIHN1Y2Nlc3NmdWwgcmVxdWVzdHMuXG4gICAgICAgICAgICB0aGlzLmZvcm0uYWpheF9zYXZlKCAkLmV4dGVuZCh0aGlzLm9wdGlvbnMsIHthamF4X3N1Y2Nlc3M6dGhpcy5oaWRlRm9ybS5iaW5kKHRoaXMpfSkgKTtcblxuICAgICAgICAgICAgLy8gLi4uIG1vdmUgZm9ybSB0byBlZGl0LXRoaXMgcGFuZWwgLi4uXG4gICAgICAgICAgICB0aGlzLmZvcm1fY29udHJvbHMgPSB0aGlzLmZvcm0uZmluZCggJzppbnB1dCcgKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodGhpcy5mb3JtLmhpZGUoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaXMgdGhlIHRhcmdldCBlbGVtZW50IHBhcnQgb2YgdGhlIHdpZGdldCBlbGVtZW50P1xuICAgICAgICBfY29udGFpbnMgOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuY2xvc2VzdCh0aGlzLmVsZW1lbnQpLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXZlbnRzIGhhbmRsZWQgYnkgdGhpcyB3aWRnZXRcbiAgICAgICAgX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jb250ZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93Rm9ybShldmVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JtX2NvbnRyb2xzWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGhpZGUgZm9ybSBvbiBjbGlja3MgdGhhdCBhcmUgbm90IHdpdGhpbiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICQoJ2JvZHknKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5fY29udGFpbnMoJChldmVudC50YXJnZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVGb3JtKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5mb3JtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlRm9ybShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdpZGdldCBpbnN0YW5jZSAoZS5nLiBlbGVtZW50IGNyZWF0aW9uLCBhcHBseSB0aGVtaW5nLCBiaW5kIGV2ZW50cyBldGMuKVxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNyZWF0ZSBcIiwgd2lkZ2V0TmFtZSwgXCIgaW5zdGFuY2UgZm9yXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9hamF4Q29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLl9nZXREYXRhT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXN0cm95IHBsdWdpbiBpbnN0YW5jZSAgYW5kIGNsZWFuIHVwIG1vZGlmaWNhdGlvbnMgdGhlIHdpZGdldCBoYXMgbWFkZSB0byB0aGUgRE9NXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRlc3Ryb3k6IFwiLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lZGl0X2ljb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmhpZGVGb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQub2ZmKCdjbGljaycpO1xuICAgICAgICAgICAgLy8gVE8gRE86IHB1dCBmb3JtIGJhY2sgZnJvbSB3aGVuY2UgaXQgY2FtZT9cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQdWJsaWMgbWV0aG9kc1xuICAgICAgICBzaG93Rm9ybSA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLnNob3coKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoICdzaG93Rm9ybScsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZUZvcm0gOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCAnaGlkZUZvcm0nLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRm9ybVZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5pcyhcIjp2aXNpYmxlXCIpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVGb3JtIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb3JtVmlzaWJsZSgpID8gdGhpcy5zaG93Rm9ybShldmVudCkgOiB0aGlzLmhpZGVGb3JtKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJChzZWxlY3RvcnNbd2lkZ2V0Q2xhc3NdKS5lZGl0X3RoaXMoKTtcblxufSkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXG4iLCIvKipcbiAqIEV4dGVuc2lvbnMgZm9yIGpRdWVyeSBVSSBXaWRnZXQgRmFjdG9yeVxuICogICAgLSBfZ2V0RGF0YU9wdGlvbnM6ICBsb2FkIG9wdGlvbnMgZnJvbSBkYXRhLW9wdGlvbiBhdHRyaWJ1dGVzIGluIGVsZW1lbnQncyBtYXJrdXBcbiAqICAgIC0gX2FqYXhDb25maWdcbiAqXG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL3V0aWwnKTtcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbiAgICBjb25zdCBhamF4X2Vycm9yX3RlbXBsYXRlID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC13YXJuaW5nIGFsZXJ0LWRpc21pc3NpYmxlXCIgcm9sZT1cImFsZXJ0XCI+JyArXG4gICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cImFsZXJ0XCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+JyArXG4gICAgICAgICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+JyArXG4gICAgICAgICAgICAnPC9idXR0b24+JyArXG4gICAgICAgICAgICAnT29wcyEgV2UgZW5jb3VudGVyZWQgYW4gZXJyb3IgcHJvY2Vzc2luZyB5b3VyIHJlcXVlc3Q6IHt0ZXh0U3RhdHVzfScgK1xuICAgICAgICAgICAgJzxicj5SZWZyZXNoIHBhZ2UgYW5kIHRyeSBhZ2Fpbj8nICtcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICB2YXIgV2lkZ2V0RXh0ZW5zaW9uc01peGluID0ge1xuICAgICAgICAvLyBMb2FkIGFueSBkYXRhLSBhdHRyaWJ1dGUgb3B0aW9ucyBmcm9tIHRoZSBlbGVtZW50J3MgdGFnXG4gICAgICAgIF9nZXREYXRhT3B0aW9ucyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRhdGFfb3B0cyA9IHRoaXMuZWxlbWVudC5kYXRhKCk7XG4gICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YV9vcHRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSBkYXRhX29wdHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgICAqIFN0YW5kYXJkaXplZCBqUXVlcnkuYWpheCBjYWxscyB3aXRoIGRlZmF1bHQgYmVoYXZpb3VycyArIHRyaWdnZXJzIGZvciBCU0Ugd2lkZ2V0c1xuICAgICAgICAgKiAgIEUuZy4sIHRoaXMuYWpheF9zdWJtaXRfZm9ybSh7IG9wdGlvbmFsX2FqYXhfc2V0dGluZ3Nfb3Jfb3ZlcnJpZGVzIH0pXG4gICAgICAgICAqICAgQWRkcyBhbiBvcHRpb25hbCBjYWxsYmFjayBhbmQgdHJpZ2dlciBmb3IgZWFjaCBsb2NhbCBBamF4IEV2ZW50LlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBBZGQgYWpheCB0cmlnZ2VyIGV2ZW50cyB0byB0aGlzIHdpZGdldCdzIG9wdGlvbnNcbiAgICAgICAgX2FqYXhDb25maWcgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAvLyBFdmVudHMgdHJpZ2dlcmVkIGJ5IGFqYXggY2FsbHMsIHVzZWQgdG8gZXh0ZW5kIHdpZGdldCBvcHRpb25zXG4gICAgICAgICAgICBjb25zdCBhamF4X2V2ZW50X29wdGlvbnM9IHtcbiAgICAgICAgICAgICAgICBhamF4X2JlZm9yZVNlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgYWpheF9zdWNjZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgIGFqYXhfZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYWpheF9jb21wbGV0ZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBhamF4X2V2ZW50X29wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyBTdWJtaXQgdGhpcy5mb3JtIGJ5IGFqYXgsIHdpdGggYW4gb3B0aW9uYWwgdGhpcy5zcGlubmVyIHRvIGRpc3BsYXkgd2hpbGUgbG9hZGluZ1xuICAgICAgICBfYWpheFN1Ym1pdEZvcm0gOiBmdW5jdGlvbihmb3JtLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBPYmplY3QuY3JlYXRlKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBmb3JtX2RhdGEgPSBmb3JtLnNlcmlhbGl6ZSgpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgZXh0cmFfZGF0YSA9IHNldHRpbmdzLmRhdGEgfHwgXCJcIjtcbiAgICAgICAgICAgIGFyZ3MuZGF0YSA9IGZvcm1fZGF0YSArIGV4dHJhX2RhdGE7XG4gICAgICAgICAgICBhcmdzLm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZCB8fCBmb3JtLmF0dHIoJ21ldGhvZCcpIHx8ICdQT1NUJztcbiAgICAgICAgICAgIGFyZ3MudXJsID0gc2V0dGluZ3MuYWN0aW9uIHx8IHNldHRpbmdzLnVybCB8fCBmb3JtLmF0dHIoJ2FjdGlvbicpO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoYXJncy51cmwsIFwiQlNFIGFqYXhTdWJtaXRGb3JtIEVycm9yOiBhIHVybCBvciBmb3JtIGFjdGlvbiBvcHRpb24gbXVzdCBiZSBzdXBwbGllZC5cIik7XG5cbiAgICAgICAgICAgIHRoaXMuX2FqYXhSZXF1ZXN0KGZvcm0sIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE1ha2UgYSBERUxFVEUgYWpheCByZXF1ZXN0IGZvciB0aGlzLmVsZW1lbnQsIHdpdGggYW4gb3B0aW9uYWwgdGhpcy5zcGlubmVyIHRvIGRpc3BsYXkgd2hpbGUgbG9hZGluZ1xuICAgICAgICBfYWpheERlbGV0ZSA6IGZ1bmN0aW9uKHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gT2JqZWN0LmNyZWF0ZShzZXR0aW5ncyk7XG4gICAgICAgICAgICBhcmdzLm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZCB8fCAnREVMRVRFJztcbiAgICAgICAgICAgIGFyZ3MudXJsID0gc2V0dGluZ3MudXJsIHx8IHNldHRpbmdzLmFjdGlvbjtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGFyZ3MudXJsLCBcIkJTRSBhamF4RGVsZXRlIEVycm9yOiBhIHVybCBtdXN0IGJlIHN1cHBsaWVkLlwiKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYWtlIEFqYXggZGVsZXRlIHJlcXVlc3RcIiwgYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9hamF4UmVxdWVzdCh0YXJnZXQsIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hamF4UmVxdWVzdDogZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYWpheF9ldmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNwaW5uZXIpIHNlbGYuc3Bpbm5lci5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmlnZ2VyKCdhamF4X2JlZm9yZVNlbmQnLCBudWxsLCB7YXJnczogYXJnc30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoanNvbiwgdGV4dFN0YXR1cywgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5tZXNzYWdlKSB0YXJnZXQuYWZ0ZXIoanNvbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXIoJ2FqYXhfc3VjY2VzcycsIG51bGwsIHthcmdzOiBhcmd1bWVudHN9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWZ0ZXIoJChhamF4X2Vycm9yX3RlbXBsYXRlLmZvcm1hdFVuaWNvcm4oe3RleHRTdGF0dXM6IHRleHRTdGF0dXN9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coeGhyLnN0YXR1cyArIFwiOiBcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlcignYWpheF9lcnJvcicsIG51bGwsIHthcmdzOiBhcmdzLCB4aHJfYXJnczogYXJndW1lbnRzfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoeGhyLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zcGlubmVyKSBzZWxmLnNwaW5uZXIuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJpZ2dlcignYWpheF9jb21wbGV0ZScsIG51bGwsIHthcmdzOiBhcmdzLCB4aHJfYXJnczogYXJndW1lbnRzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkLmFqYXgoJC5leHRlbmQoYWpheF9ldmVudHMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoJ1dpZGdldCcgaW4gJCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKCQuV2lkZ2V0LnByb3RvdHlwZSwgV2lkZ2V0RXh0ZW5zaW9uc01peGluKTtcbiAgICB9XG59KShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuIiwiLyohIGpRdWVyeSBVSSAtIHYxLjEyLjEgLSAyMDE4LTA2LTA1XG4qIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiogSW5jbHVkZXM6IHdpZGdldC5qcywgcG9zaXRpb24uanNcbiogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnM7IExpY2Vuc2VkIE1JVCAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFsgXCJqcXVlcnlcIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufShmdW5jdGlvbiggJCApIHtcblxuJC51aSA9ICQudWkgfHwge307XG5cbnZhciB2ZXJzaW9uID0gJC51aS52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFdpZGdldFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgc3RhdGVmdWwgd2lkZ2V0cyB3aXRoIGEgY29tbW9uIEFQSS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3dpZGdldC9cblxuXG5cbnZhciB3aWRnZXRVdWlkID0gMDtcbnZhciB3aWRnZXRTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuJC5jbGVhbkRhdGEgPSAoIGZ1bmN0aW9uKCBvcmlnICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBldmVudHMsIGVsZW0sIGk7XG5cdFx0Zm9yICggaSA9IDA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdC8vIE9ubHkgdHJpZ2dlciByZW1vdmUgd2hlbiBuZWNlc3NhcnkgdG8gc2F2ZSB0aW1lXG5cdFx0XHRcdGV2ZW50cyA9ICQuX2RhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHRcdFx0aWYgKCBldmVudHMgJiYgZXZlbnRzLnJlbW92ZSApIHtcblx0XHRcdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIdHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0fVxuXHRcdG9yaWcoIGVsZW1zICk7XG5cdH07XG59ICkoICQuY2xlYW5EYXRhICk7XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlO1xuXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0dmFyIHByb3hpZWRQcm90b3R5cGUgPSB7fTtcblxuXHR2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0aWYgKCAkLmlzQXJyYXkoIHByb3RvdHlwZSApICkge1xuXHRcdHByb3RvdHlwZSA9ICQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIHt9IF0uY29uY2F0KCBwcm90b3R5cGUgKSApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblxuXHRcdC8vIFRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9ICk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cblx0Ly8gV2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gX3N1cGVyKCkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIF9zdXBlckFwcGx5KCBhcmdzICkge1xuXHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXI7XG5cdFx0XHRcdHZhciBfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5O1xuXHRcdFx0XHR2YXIgcmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9ICkoKTtcblx0fSApO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblxuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/ICggYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lICkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSApO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gUmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLFxuXHRcdFx0XHRjaGlsZC5fcHJvdG8gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xuXG5cdHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHR2YXIgaW5wdXRJbmRleCA9IDA7XG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0dmFyIGtleTtcblx0dmFyIHZhbHVlO1xuXG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiO1xuXHRcdHZhciBhcmdzID0gd2lkZ2V0U2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVtcHR5IGNvbGxlY3Rpb24sIHdlIG5lZWQgdG8gaGF2ZSB0aGUgaW5zdGFuY2UgbWV0aG9kXG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhlIGpRdWVyeSBpbnN0YW5jZVxuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggJiYgb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblxuXHRcdFx0XHRcdGlmICggb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBpbnN0YW5jZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVsgb3B0aW9ucyBdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KCBhcmdzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApO1xuXHRcdFx0XHRcdGlmICggaW5zdGFuY2UuX2luaXQgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7fSxcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRVdWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblx0XHR0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge307XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblxuXHRcdFx0XHQvLyBFbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCB2YWx1ZSwga2V5ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gV2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIENsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0fSxcblxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5O1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgY3VyT3B0aW9uO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBEb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjbGFzc2VzXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25DbGFzc2VzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uQ2xhc3NlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcblxuXHRcdGZvciAoIGNsYXNzS2V5IGluIHZhbHVlICkge1xuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcblx0XHRcdGlmICggdmFsdWVbIGNsYXNzS2V5IF0gPT09IHRoaXMub3B0aW9ucy5jbGFzc2VzWyBjbGFzc0tleSBdIHx8XG5cdFx0XHRcdFx0IWN1cnJlbnRFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYXJlIGRvaW5nIHRoaXMgdG8gY3JlYXRlIGEgbmV3IGpRdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgX3JlbW92ZUNsYXNzKCkgY2FsbFxuXHRcdFx0Ly8gb24gdGhlIG5leHQgbGluZSBpcyBnb2luZyB0byBkZXN0cm95IHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZWxlbWVudHMgYmVpbmdcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcblx0XHRcdC8vIGJlbG93LlxuXHRcdFx0ZWxlbWVudHMgPSAkKCBjdXJyZW50RWxlbWVudHMuZ2V0KCkgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfYWRkQ2xhc3MoKSBoZXJlLCBiZWNhdXNlIHRoYXQgdXNlcyB0aGlzLm9wdGlvbnMuY2xhc3Nlc1xuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cblx0XHRcdC8vIF9zZXRPcHRpb24oKSwgdGhpcyBpcyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjbGFzc2VzIG9wdGlvbiB3aGljaCB3YXMgcGFzc2VkIHRvXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCkuIFdlIHBhc3MgdGhpcyB2YWx1ZSBkaXJlY3RseSB0byBfY2xhc3NlcygpLlxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudHMsXG5cdFx0XHRcdGtleXM6IGNsYXNzS2V5LFxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcblx0XHRcdFx0YWRkOiB0cnVlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0KCksIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCBudWxsLCAhIXZhbHVlICk7XG5cblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaG92ZXJhYmxlLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XG5cdH0sXG5cblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBmdWxsID0gW107XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NDbGFzc1N0cmluZyggY2xhc3NlcywgY2hlY2tPcHRpb24gKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgaTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y3VycmVudCA9IHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdIHx8ICQoKTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmFkZCApIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggJC51bmlxdWUoIGN1cnJlbnQuZ2V0KCkuY29uY2F0KCBvcHRpb25zLmVsZW1lbnQuZ2V0KCkgKSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoIGN1cnJlbnQubm90KCBvcHRpb25zLmVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzZXNbIGkgXSBdID0gY3VycmVudDtcblx0XHRcdFx0ZnVsbC5wdXNoKCBjbGFzc2VzWyBpIF0gKTtcblx0XHRcdFx0aWYgKCBjaGVja09wdGlvbiAmJiBvcHRpb25zLmNsYXNzZXNbIGNsYXNzZXNbIGkgXSBdICkge1xuXHRcdFx0XHRcdGZ1bGwucHVzaCggb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIG9wdGlvbnMuZWxlbWVudCwge1xuXHRcdFx0XCJyZW1vdmVcIjogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5rZXlzLm1hdGNoKCAvXFxTKy9nICkgfHwgW10sIHRydWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmV4dHJhLm1hdGNoKCAvXFxTKy9nICkgfHwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVsbC5qb2luKCBcIiBcIiApO1xuXHR9LFxuXG5cdF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBldmVudC50YXJnZXQsIHZhbHVlICkgIT09IC0xICkge1xuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBrZXkgXSA9ICQoIHZhbHVlLm5vdCggZXZlbnQudGFyZ2V0ICkuZ2V0KCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgZmFsc2UgKTtcblx0fSxcblxuXHRfYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcblx0XHRhZGQgPSAoIHR5cGVvZiBhZGQgPT09IFwiYm9vbGVhblwiICkgPyBhZGQgOiBleHRyYTtcblx0XHR2YXIgc2hpZnQgPSAoIHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiIHx8IGVsZW1lbnQgPT09IG51bGwgKSxcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGV4dHJhOiBzaGlmdCA/IGtleXMgOiBleHRyYSxcblx0XHRcdFx0a2V5czogc2hpZnQgPyBlbGVtZW50IDoga2V5cyxcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxuXHRcdFx0XHRhZGQ6IGFkZFxuXHRcdFx0fTtcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50O1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBObyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXG5cdFx0XHRcdC8vIEFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKTtcblx0XHRcdHZhciBldmVudE5hbWUgPSBtYXRjaFsgMSBdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2U7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5vbiggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoIGV2ZW50TmFtZSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgK1xuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50Lm9mZiggZXZlbnROYW1lICkub2ZmKCBldmVudE5hbWUgKTtcblxuXHRcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1Nilcblx0XHR0aGlzLmJpbmRpbmdzID0gJCggdGhpcy5iaW5kaW5ncy5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCggdGhpcy5mb2N1c2FibGUubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoIHRoaXMuaG92ZXJhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWc7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIENvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WyAwIF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIGhhc09wdGlvbnM7XG5cdFx0dmFyIGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRtZXRob2QgOlxuXHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKCBmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbnZhciB3aWRnZXQgPSAkLndpZGdldDtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBQb3NpdGlvbiAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuICovXG5cbi8vPj5sYWJlbDogUG9zaXRpb25cbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQb3NpdGlvbnMgZWxlbWVudHMgcmVsYXRpdmUgdG8gb3RoZXIgZWxlbWVudHMuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcG9zaXRpb24vXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vcG9zaXRpb24vXG5cblxuKCBmdW5jdGlvbigpIHtcbnZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCxcblx0bWF4ID0gTWF0aC5tYXgsXG5cdGFicyA9IE1hdGguYWJzLFxuXHRyaG9yaXpvbnRhbCA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXG5cdHJ2ZXJ0aWNhbCA9IC90b3B8Y2VudGVyfGJvdHRvbS8sXG5cdHJvZmZzZXQgPSAvW1xcK1xcLV1cXGQrKFxcLltcXGRdKyk/JT8vLFxuXHRycG9zaXRpb24gPSAvXlxcdysvLFxuXHRycGVyY2VudCA9IC8lJC8sXG5cdF9wb3NpdGlvbiA9ICQuZm4ucG9zaXRpb247XG5cbmZ1bmN0aW9uIGdldE9mZnNldHMoIG9mZnNldHMsIHdpZHRoLCBoZWlnaHQgKSB7XG5cdHJldHVybiBbXG5cdFx0cGFyc2VGbG9hdCggb2Zmc2V0c1sgMCBdICkgKiAoIHJwZXJjZW50LnRlc3QoIG9mZnNldHNbIDAgXSApID8gd2lkdGggLyAxMDAgOiAxICksXG5cdFx0cGFyc2VGbG9hdCggb2Zmc2V0c1sgMSBdICkgKiAoIHJwZXJjZW50LnRlc3QoIG9mZnNldHNbIDEgXSApID8gaGVpZ2h0IC8gMTAwIDogMSApXG5cdF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApIHtcblx0cmV0dXJuIHBhcnNlSW50KCAkLmNzcyggZWxlbWVudCwgcHJvcGVydHkgKSwgMTAgKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKCBlbGVtICkge1xuXHR2YXIgcmF3ID0gZWxlbVsgMCBdO1xuXHRpZiAoIHJhdy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IDAsIGxlZnQ6IDAgfVxuXHRcdH07XG5cdH1cblx0aWYgKCAkLmlzV2luZG93KCByYXcgKSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IGVsZW0uc2Nyb2xsVG9wKCksIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpIH1cblx0XHR9O1xuXHR9XG5cdGlmICggcmF3LnByZXZlbnREZWZhdWx0ICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdG9mZnNldDogeyB0b3A6IHJhdy5wYWdlWSwgbGVmdDogcmF3LnBhZ2VYIH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0d2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdGhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdG9mZnNldDogZWxlbS5vZmZzZXQoKVxuXHR9O1xufVxuXG4kLnBvc2l0aW9uID0ge1xuXHRzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHRcdH1cblx0XHR2YXIgdzEsIHcyLFxuXHRcdFx0ZGl2ID0gJCggXCI8ZGl2IFwiICtcblx0XHRcdFx0XCJzdHlsZT0nZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OmhpZGRlbjsnPlwiICtcblx0XHRcdFx0XCI8ZGl2IHN0eWxlPSdoZWlnaHQ6MTAwcHg7d2lkdGg6YXV0bzsnPjwvZGl2PjwvZGl2PlwiICksXG5cdFx0XHRpbm5lckRpdiA9IGRpdi5jaGlsZHJlbigpWyAwIF07XG5cblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggZGl2ICk7XG5cdFx0dzEgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblx0XHRkaXYuY3NzKCBcIm92ZXJmbG93XCIsIFwic2Nyb2xsXCIgKTtcblxuXHRcdHcyID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cblx0XHRpZiAoIHcxID09PSB3MiApIHtcblx0XHRcdHcyID0gZGl2WyAwIF0uY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0ZGl2LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3MSAtIHcyICk7XG5cdH0sXG5cdGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCB3aXRoaW4gKSB7XG5cdFx0dmFyIG92ZXJmbG93WCA9IHdpdGhpbi5pc1dpbmRvdyB8fCB3aXRoaW4uaXNEb2N1bWVudCA/IFwiXCIgOlxuXHRcdFx0XHR3aXRoaW4uZWxlbWVudC5jc3MoIFwib3ZlcmZsb3cteFwiICksXG5cdFx0XHRvdmVyZmxvd1kgPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXlcIiApLFxuXHRcdFx0aGFzT3ZlcmZsb3dYID0gb3ZlcmZsb3dYID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dYID09PSBcImF1dG9cIiAmJiB3aXRoaW4ud2lkdGggPCB3aXRoaW4uZWxlbWVudFsgMCBdLnNjcm9sbFdpZHRoICksXG5cdFx0XHRoYXNPdmVyZmxvd1kgPSBvdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1kgPT09IFwiYXV0b1wiICYmIHdpdGhpbi5oZWlnaHQgPCB3aXRoaW4uZWxlbWVudFsgMCBdLnNjcm9sbEhlaWdodCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogaGFzT3ZlcmZsb3dYID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMFxuXHRcdH07XG5cdH0sXG5cdGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB3aXRoaW5FbGVtZW50ID0gJCggZWxlbWVudCB8fCB3aW5kb3cgKSxcblx0XHRcdGlzV2luZG93ID0gJC5pc1dpbmRvdyggd2l0aGluRWxlbWVudFsgMCBdICksXG5cdFx0XHRpc0RvY3VtZW50ID0gISF3aXRoaW5FbGVtZW50WyAwIF0gJiYgd2l0aGluRWxlbWVudFsgMCBdLm5vZGVUeXBlID09PSA5LFxuXHRcdFx0aGFzT2Zmc2V0ID0gIWlzV2luZG93ICYmICFpc0RvY3VtZW50O1xuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50OiB3aXRoaW5FbGVtZW50LFxuXHRcdFx0aXNXaW5kb3c6IGlzV2luZG93LFxuXHRcdFx0aXNEb2N1bWVudDogaXNEb2N1bWVudCxcblx0XHRcdG9mZnNldDogaGFzT2Zmc2V0ID8gJCggZWxlbWVudCApLm9mZnNldCgpIDogeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0d2lkdGg6IHdpdGhpbkVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB3aXRoaW5FbGVtZW50Lm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9XG59O1xuXG4kLmZuLnBvc2l0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdGlmICggIW9wdGlvbnMgfHwgIW9wdGlvbnMub2YgKSB7XG5cdFx0cmV0dXJuIF9wb3NpdGlvbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHQvLyBNYWtlIGEgY29weSwgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgYXJndW1lbnRzXG5cdG9wdGlvbnMgPSAkLmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgYXRPZmZzZXQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRhcmdldE9mZnNldCwgYmFzZVBvc2l0aW9uLCBkaW1lbnNpb25zLFxuXHRcdHRhcmdldCA9ICQoIG9wdGlvbnMub2YgKSxcblx0XHR3aXRoaW4gPSAkLnBvc2l0aW9uLmdldFdpdGhpbkluZm8oIG9wdGlvbnMud2l0aGluICksXG5cdFx0c2Nyb2xsSW5mbyA9ICQucG9zaXRpb24uZ2V0U2Nyb2xsSW5mbyggd2l0aGluICksXG5cdFx0Y29sbGlzaW9uID0gKCBvcHRpb25zLmNvbGxpc2lvbiB8fCBcImZsaXBcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdG9mZnNldHMgPSB7fTtcblxuXHRkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggdGFyZ2V0ICk7XG5cdGlmICggdGFyZ2V0WyAwIF0ucHJldmVudERlZmF1bHQgKSB7XG5cblx0XHQvLyBGb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xuXHRcdG9wdGlvbnMuYXQgPSBcImxlZnQgdG9wXCI7XG5cdH1cblx0dGFyZ2V0V2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuXHR0YXJnZXRIZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcblx0dGFyZ2V0T2Zmc2V0ID0gZGltZW5zaW9ucy5vZmZzZXQ7XG5cblx0Ly8gQ2xvbmUgdG8gcmV1c2Ugb3JpZ2luYWwgdGFyZ2V0T2Zmc2V0IGxhdGVyXG5cdGJhc2VQb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgdGFyZ2V0T2Zmc2V0ICk7XG5cblx0Ly8gRm9yY2UgbXkgYW5kIGF0IHRvIGhhdmUgdmFsaWQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcG9zaXRpb25zXG5cdC8vIGlmIGEgdmFsdWUgaXMgbWlzc2luZyBvciBpbnZhbGlkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBjZW50ZXJcblx0JC5lYWNoKCBbIFwibXlcIiwgXCJhdFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3MgPSAoIG9wdGlvbnNbIHRoaXMgXSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0XHRob3Jpem9udGFsT2Zmc2V0LFxuXHRcdFx0dmVydGljYWxPZmZzZXQ7XG5cblx0XHRpZiAoIHBvcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRwb3MgPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0cG9zLmNvbmNhdCggWyBcImNlbnRlclwiIF0gKSA6XG5cdFx0XHRcdHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0XHRbIFwiY2VudGVyXCIgXS5jb25jYXQoIHBvcyApIDpcblx0XHRcdFx0XHRbIFwiY2VudGVyXCIsIFwiY2VudGVyXCIgXTtcblx0XHR9XG5cdFx0cG9zWyAwIF0gPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID8gcG9zWyAwIF0gOiBcImNlbnRlclwiO1xuXHRcdHBvc1sgMSBdID0gcnZlcnRpY2FsLnRlc3QoIHBvc1sgMSBdICkgPyBwb3NbIDEgXSA6IFwiY2VudGVyXCI7XG5cblx0XHQvLyBDYWxjdWxhdGUgb2Zmc2V0c1xuXHRcdGhvcml6b250YWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMCBdICk7XG5cdFx0dmVydGljYWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMSBdICk7XG5cdFx0b2Zmc2V0c1sgdGhpcyBdID0gW1xuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXRbIDAgXSA6IDAsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0WyAwIF0gOiAwXG5cdFx0XTtcblxuXHRcdC8vIFJlZHVjZSB0byBqdXN0IHRoZSBwb3NpdGlvbnMgd2l0aG91dCB0aGUgb2Zmc2V0c1xuXHRcdG9wdGlvbnNbIHRoaXMgXSA9IFtcblx0XHRcdHJwb3NpdGlvbi5leGVjKCBwb3NbIDAgXSApWyAwIF0sXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAxIF0gKVsgMCBdXG5cdFx0XTtcblx0fSApO1xuXG5cdC8vIE5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sbGlzaW9uUG9zaXRpb24sIHVzaW5nLFxuXHRcdFx0ZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdGVsZW1XaWR0aCA9IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZWxlbUhlaWdodCA9IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRcdG1hcmdpbkxlZnQgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5MZWZ0XCIgKSxcblx0XHRcdG1hcmdpblRvcCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblRvcFwiICksXG5cdFx0XHRjb2xsaXNpb25XaWR0aCA9IGVsZW1XaWR0aCArIG1hcmdpbkxlZnQgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5SaWdodFwiICkgK1xuXHRcdFx0XHRzY3JvbGxJbmZvLndpZHRoLFxuXHRcdFx0Y29sbGlzaW9uSGVpZ2h0ID0gZWxlbUhlaWdodCArIG1hcmdpblRvcCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkJvdHRvbVwiICkgK1xuXHRcdFx0XHRzY3JvbGxJbmZvLmhlaWdodCxcblx0XHRcdHBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCBiYXNlUG9zaXRpb24gKSxcblx0XHRcdG15T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5teSwgZWxlbS5vdXRlcldpZHRoKCksIGVsZW0ub3V0ZXJIZWlnaHQoKSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoO1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoIC8gMjtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0WyAwIF07XG5cdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0WyAxIF07XG5cblx0XHRjb2xsaXNpb25Qb3NpdGlvbiA9IHtcblx0XHRcdG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG5cdFx0XHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxuXHRcdH07XG5cblx0XHQkLmVhY2goIFsgXCJsZWZ0XCIsIFwidG9wXCIgXSwgZnVuY3Rpb24oIGksIGRpciApIHtcblx0XHRcdGlmICggJC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXSApIHtcblx0XHRcdFx0JC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXVsgZGlyIF0oIHBvc2l0aW9uLCB7XG5cdFx0XHRcdFx0dGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGVsZW1XaWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdGVsZW1IZWlnaHQ6IGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0Y29sbGlzaW9uUG9zaXRpb246IGNvbGxpc2lvblBvc2l0aW9uLFxuXHRcdFx0XHRcdGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcblx0XHRcdFx0XHRjb2xsaXNpb25IZWlnaHQ6IGNvbGxpc2lvbkhlaWdodCxcblx0XHRcdFx0XHRvZmZzZXQ6IFsgYXRPZmZzZXRbIDAgXSArIG15T2Zmc2V0WyAwIF0sIGF0T2Zmc2V0IFsgMSBdICsgbXlPZmZzZXRbIDEgXSBdLFxuXHRcdFx0XHRcdG15OiBvcHRpb25zLm15LFxuXHRcdFx0XHRcdGF0OiBvcHRpb25zLmF0LFxuXHRcdFx0XHRcdHdpdGhpbjogd2l0aGluLFxuXHRcdFx0XHRcdGVsZW06IGVsZW1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggb3B0aW9ucy51c2luZyApIHtcblxuXHRcdFx0Ly8gQWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcblx0XHRcdHVzaW5nID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcblx0XHRcdFx0XHR0b3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHRhcmdldEhlaWdodCAtIGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0ZmVlZGJhY2sgPSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0YXJnZXRPZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogdGFyZ2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtSGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXCJsZWZ0XCIgOiBsZWZ0ID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFwidG9wXCIgOiB0b3AgPiAwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyggbGVmdCArIHJpZ2h0ICkgPCB0YXJnZXRXaWR0aCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5ob3Jpem9udGFsID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRhcmdldEhlaWdodCA8IGVsZW1IZWlnaHQgJiYgYWJzKCB0b3AgKyBib3R0b20gKSA8IHRhcmdldEhlaWdodCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXgoIGFicyggbGVmdCApLCBhYnMoIHJpZ2h0ICkgKSA+IG1heCggYWJzKCB0b3AgKSwgYWJzKCBib3R0b20gKSApICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwiaG9yaXpvbnRhbFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwidmVydGljYWxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIHRoaXMsIHByb3BzLCBmZWVkYmFjayApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbGVtLm9mZnNldCggJC5leHRlbmQoIHBvc2l0aW9uLCB7IHVzaW5nOiB1c2luZyB9ICkgKTtcblx0fSApO1xufTtcblxuJC51aS5wb3NpdGlvbiA9IHtcblx0Zml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0b3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zTGVmdCxcblx0XHRcdFx0b3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdC8vIEVsZW1lbnQgaXMgd2lkZXIgdGhhbiB3aXRoaW5cblx0XHRcdGlmICggZGF0YS5jb2xsaXNpb25XaWR0aCA+IG91dGVyV2lkdGggKSB7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgbGVmdCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgb3ZlckxlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtXG5cdFx0XHRcdFx0XHR3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdCAtIG5ld092ZXJSaWdodDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgJiYgb3ZlckxlZnQgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldCArIG91dGVyV2lkdGggLSBkYXRhLmNvbGxpc2lvbldpZHRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb28gZmFyIGxlZnQgLT4gYWxpZ24gd2l0aCBsZWZ0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJMZWZ0ID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdDtcblxuXHRcdFx0Ly8gVG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gb3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBBZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IG1heCggcG9zaXRpb24ubGVmdCAtIGNvbGxpc2lvblBvc0xlZnQsIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gZGF0YS53aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc1RvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cblx0XHRcdC8vIEVsZW1lbnQgaXMgdGFsbGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uSGVpZ2h0ID4gb3V0ZXJIZWlnaHQgKSB7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgdG9wIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJUb3AgPiAwICYmIG92ZXJCb3R0b20gPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgb3ZlclRvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLVxuXHRcdFx0XHRcdFx0d2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wIC0gbmV3T3ZlckJvdHRvbTtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdHRvbSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgJiYgb3ZlclRvcCA8PSAwICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggdG9wIGFuZCBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyVG9wID4gb3ZlckJvdHRvbSApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9vIGZhciB1cCAtPiBhbGlnbiB3aXRoIHRvcFxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclRvcCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wO1xuXG5cdFx0XHQvLyBUb28gZmFyIGRvd24gLT4gYWxpZ24gd2l0aCBib3R0b20gZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCAtPSBvdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBBZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24udG9wID0gbWF4KCBwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG15T2Zmc2V0ID0gZGF0YS5teVsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLm15WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDAgXSxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0LFxuXHRcdFx0XHRuZXdPdmVyTGVmdDtcblxuXHRcdFx0aWYgKCBvdmVyTGVmdCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtXG5cdFx0XHRcdFx0b3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyUmlnaHQgPCAwIHx8IG5ld092ZXJSaWdodCA8IGFicyggb3ZlckxlZnQgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCArIG15T2Zmc2V0ICtcblx0XHRcdFx0XHRhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldExlZnQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlckxlZnQgPiAwIHx8IGFicyggbmV3T3ZlckxlZnQgKSA8IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LnRvcCArIHdpdGhpbi5zY3JvbGxUb3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcblx0XHRcdFx0b2Zmc2V0VG9wID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdHRvcCA9IGRhdGEubXlbIDEgXSA9PT0gXCJ0b3BcIixcblx0XHRcdFx0bXlPZmZzZXQgPSB0b3AgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEubXlbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAxIF0gPT09IFwidG9wXCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLmF0WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDEgXSxcblx0XHRcdFx0bmV3T3ZlclRvcCxcblx0XHRcdFx0bmV3T3ZlckJvdHRvbTtcblx0XHRcdGlmICggb3ZlclRvcCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLVxuXHRcdFx0XHRcdG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMoIG92ZXJUb3AgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgK1xuXHRcdFx0XHRcdG9mZnNldCAtIG9mZnNldFRvcDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXBmaXQ6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdCQudWkucG9zaXRpb24uZmxpcC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdCQudWkucG9zaXRpb24uZmxpcC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbn0gKSgpO1xuXG52YXIgcG9zaXRpb24gPSAkLnVpLnBvc2l0aW9uO1xuXG5cblxuXG59KSk7IiwiLyoqXG4gKiBCb290c3RyYXAgRXh0cmFzICh2MC4xKTogbWFpbi5qc1xuICogICAtLSBDb2xsYXRlIGFsbCBjb21wb25lbnQgc2NyaXB0cyB2aWEgQnJvc3dlcmlmeSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9icm93c2VyaWZ5XG4gKlxuICogICBFeHRlcm5hbCBEZXBlbmRlbmNpZXM6ICBCb290c3RyYXAgMyArIEpRdWVyeSAyK1xuICogICBNSVQgT3Blbi1zb3VyY2UgTGljZW5zZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bvd2RlcmZsYXNrL2Jvb3RzdHJhcF9leHRyYXMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuXG5yZXF1aXJlKCcuL2FqYXhfZGVsZXRlJyk7XG5yZXF1aXJlKCcuL2FqYXhfc2F2ZScpO1xucmVxdWlyZSgnLi9lZGl0LXRoaXMnKTtcbnJlcXVpcmUoJy4vY29sX2NvbGxhcHNlJyk7XG5yZXF1aXJlKCcuL3Byb2dyZXNzX3JlcG9ydCcpO1xucmVxdWlyZSgnLi9zcGlubmVyJyk7XG5yZXF1aXJlKCcuL3RvZ2dsZV90aGF0Jyk7XG4iLCIvKipcbiAqIFByb2dyZXNzIFJlcG9ydCBDb21wb25lbnQgKHYwLjEpOiBwcm9ncmVzc19yZXBvcnQuanNcbiAqICAgLS0gYSBCb290c3RyYXAgUHJvZ3Jlc3MgQmFyIHdpdGggYW4gaW50ZXJhY3RpdmUgcmFuZ2UgaW5wdXRcbiAqICAgLS0gQUpBWCBzYXZlIHNlbGVjdGVkIHZhbHVlIHVzaW5nIHN0YW5kYXJkIEhNVEwgZm9ybS5cbiAqXG4gKiAgIERlcGVuZGVuY2llczogIEJvb3RzdHJhcCArIEpRdWVyeSArIHNwaW5uZXJcbiAqICAgTUlUIE9wZW4tc291cmNlIExpY2Vuc2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9wb3dkZXJmbGFzay9ib290c3RyYXBfZXh0cmFzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cbnJlcXVpcmUoICcuL3NwaW5uZXInKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSggJy4vdXRpbCcgKTtcblxuOyhmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4gICAgdmFyIHdpZGdldE5hbWUgPSAnYnNlLnByb2dyZXNzX3JlcG9ydCcsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1wcm9ncmVzcy1yZXBvcnQnLFxuICAgICAgICBjbGFzc2VzID0gd2lkZ2V0Q2xhc3MuYnVpbGROYW1lc01hcChbJ3BhbmVsJywgJ2Zvcm0nLCAndmFsdWUnXSksXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoW10sICcuJyksXG5cbiAgICAgICAgbWFya3VwID0ge1xuICAgICAgICAgICAgcGFuZWwgOiBbJzxkaXY+JywgeydjbGFzcyc6IGNsYXNzZXMucGFuZWx9XSxcbiAgICAgICAgICAgIGZvcm0gOiBbJzxmb3JtPicsIHsnY2xhc3MnOiBjbGFzc2VzLmZvcm19XSxcbiAgICAgICAgICAgIGlucHV0IDogWyc8aW5wdXQ+Jywge3R5cGU6J3JhbmdlJywgJ2NsYXNzJzogd2lkZ2V0Q2xhc3MsIG5hbWU6Y2xhc3Nlcy52YWx1ZSwgcmVxdWlyZWQ6Jyd9XVxuICAgICAgICB9O1xuXG4gICAgJC53aWRnZXQoIHdpZGdldE5hbWUsIHtcblxuICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICBhY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrcyAoYWpheCBldmVudCBjYWxsYmFja3MgYWxzbyB0cmlnZ2VyKVxuICAgICAgICAgICAgc2F2ZUZvcm06IG51bGwgICAvLyBjYWxsZWQgd2hlbiByYW5nZV9pbnB1dCBpcyBjaGFuZ2VkLCBiZWZvcmUgc2F2aW5nIC0gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUZW1wbGF0ZSBub2RlIGZvciB0aGUgd2lkZ2V0XG4gICAgICAgIF90ZW1wbGF0ZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZWxlbWVudC5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc19iYXIgPSB0aGlzLnByb2dyZXNzLmZpbmQoJy5wcm9ncmVzcy1iYXInKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnByb2dyZXNzX2Jhci5hdHRyKCdhcmlhLXZhbHVlbm93Jyk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlX2lucHV0ID0gJC5hcHBseSh0aGlzLCBtYXJrdXAuaW5wdXQpOyAgLy8gJCguLi5tYXJrdXAuaW5wdXQpXG4gICAgICAgICAgICB0aGlzLmZvcm0gPSAkLmFwcGx5KHRoaXMsIG1hcmt1cC5mb3JtKS5hcHBlbmQodGhpcy5yYW5nZV9pbnB1dCk7XG4gICAgICAgICAgICB0aGlzLnBhbmVsID0gJC5hcHBseSh0aGlzLCBtYXJrdXAucGFuZWwpLmFwcGVuZCh0aGlzLnByb2dyZXNzKS5hcHBlbmQodGhpcy5mb3JtKTtcblxuICAgICAgICAgICAgLy8gQ29uZmlndXJlIG9wdGlvbmFsIEFqYXggc2F2ZSB3aXRoIGNhbGxiYWNrIHRvIGhpZGUgZm9ybSBvbiBzdWNjZXNzZnVsIHJlcXVlc3RzLlxuICAgICAgICAgICAgdGhpcy5mb3JtLmFqYXhfc2F2ZSggJC5leHRlbmQodGhpcy5vcHRpb25zLCB7YWpheF9zdWNjZXNzOnRoaXMuZm9ybS5oaWRlLmJpbmQodGhpcy5mb3JtKX0pICk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlX2lucHV0LmF0dHIoJ21pbicsIHRoaXMub3B0aW9ucy5taW4pLmF0dHIoJ21heCcsIHRoaXMub3B0aW9ucy5tYXgpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZV9pbnB1dC52YWwodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV2ZW50cyBoYW5kbGVkIGJ5IHRoaXMgd2lkZ2V0XG4gICAgICAgIF9jb25maWd1cmVFdmVudEhhbmRsZXJzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc3Bpbm5lciA9IHNlbGYuZm9ybS5zcGlubmVyKCdpbnN0YW5jZScpOyAgLy8gb3VjaCAtIHRpZ2h0IGNvdXBsaW5nIHRvIGFqYXgtc2F2ZSBoZXJlLlxuXG4gICAgICAgICAgICB0aGlzLnJhbmdlX2lucHV0Lm9uKCdpbnB1dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi52YWx1ZSA9IHNlbGYucmFuZ2VfaW5wdXQudmFsKCkgfHwgMDtcbiAgICAgICAgICAgICAgICBzZWxmLnByb2dyZXNzX2Jhci50ZXh0KHNlbGYudmFsdWUgKyAnJSBDb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIHNlbGYucHJvZ3Jlc3NfYmFyLmNzcyggJ3dpZHRoJywgc2VsZi52YWx1ZSsnJScpO1xuICAgICAgICAgICAgICAgIHNwaW5uZXIucG9zaXRpb24oIHt0b3A6ICctMWVtJywgbGVmdDooc2VsZi52YWx1ZS0xKSsnJSd9ICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcy5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZm9ybS5zaG93KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yYW5nZV9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHNlbGYucmFuZ2VfaW5wdXQuYmx1cihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICBzZWxmLmZvcm0uaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZm9ybS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JtLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ3JlYXRlIFwiLCB3aWRnZXROYW1lLCBcIiBpbnN0YW5jZSBmb3JcIiwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2FqYXhDb25maWcoKTtcbiAgICAgICAgICAgIHRoaXMuX2dldERhdGFPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWZ0ZXIodGhpcy5fdGVtcGxhdGUoKSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERlc3Ryb3kgcGx1Z2luIGluc3RhbmNlICBhbmQgY2xlYW4gdXAgbW9kaWZpY2F0aW9ucyB0aGUgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVzdHJveTogXCIsIHRoaXMucGFuZWwpO1xuICAgICAgICAgICAgdGhpcy5wYW5lbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQoc2VsZWN0b3JzW3dpZGdldENsYXNzXSkucHJvZ3Jlc3NfcmVwb3J0KCk7XG5cbn0pKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblxuIiwiLyoqXG4gKiBBSkFYIExvYWRpbmcgU3Bpbm5lciAodjAuMSk6IHNwaW5uZXIuanNcbiAqICAgLS0gYSBKUXVlcnkgcGx1Z2luIHNwaW5uZXIgdG8gc2lnbmFsIGFzeW4gcmVxdWVzdCBpbi1wcm9ncmVzc1xuICogICAtLSBzaG93IC8gaGlkZSBzcGlubmVyIGNhbiBvcHRpb25hbGx5IGNvbnRyb2wgZW5hYmxlL2Rpc2FibGUgd2lkZ2V0J3MgZWxlbWVudFxuICpcbiAqICAgRGVwZW5kZW5jaWVzOiAgQm9vdHN0cmFwICsgSlF1ZXJ5XG4gKiAgIE1JVCBPcGVuLXNvdXJjZSBMaWNlbnNlIChodHRwczovL2dpdGh1Yi5jb20vcG93ZGVyZmxhc2svYm9vdHN0cmFwX2V4dHJhcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQnKTtcbnJlcXVpcmUoICcuL2pxdWVyeS11aS13aWRnZXQtZXh0ZW5zaW9ucycpO1xuXG47KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbiAgICB2YXIgd2lkZ2V0TmFtZSA9ICdic2Uuc3Bpbm5lcicsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS1zcGlubmVyJyxcbiAgICAgICAgc2VsZWN0b3JzID0ge1xuICAgICAgICAgICAgJ2FwcGVuZCcgOiAnLicrd2lkZ2V0Q2xhc3MrJy1hcHBlbmQnXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmt1cCA9IHtcbiAgICAgICAgICAgIHNwaW5uZXI6IFsnPHNwYW4+JywgeydjbGFzcyc6IHdpZGdldENsYXNzfV1cbiAgICAgICAgfTtcblxuICAgICQud2lkZ2V0KCB3aWRnZXROYW1lLCB7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0byBiZSB1c2VkIGFzIGRlZmF1bHRzXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNwaW5fdGV4dDogJ1NhdmluZy4uLicsICAvLyB0aXRsZSBhbmQgYWNjZXNzaWJpbGl0eSB0ZXh0IGZvciBzcGlubmVyXG4gICAgICAgICAgICBkaXNhYmxlX29uX3NwaW46IGZhbHNlLCAgLy8gc2V0IHRvIHRydWUgdG8gZGlzYWJsZSBhbGwgOmlucHV0cyBpbiB0aGUgcGFyZW50IGVsZW1lbnQgd2hlbiBzcGlubmVyIHNob3dzXG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgaGlkZGVuOiBudWxsLCAgIC8vIHRyaWdnZXJzIHdoZW4gc3Bpbm5lciBpcyBoaWRkZW5cbiAgICAgICAgICAgIHNob3duOiBudWxsICAgICAvLyB0cmlnZ2VycyB3aGVuIHNwaW5uZXIgaXMgc2hvd25cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUZW1wbGF0ZSBub2RlIGZvciB0aGUgd2lkZ2V0XG4gICAgICAgIF90ZW1wbGF0ZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICQuYXBwbHkodGhpcywgbWFya3VwLnNwaW5uZXIpLmhpZGUoKS5odG1sKHRoaXMub3B0aW9ucy5zcGluX3RleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREaXNhYmxlVGFyZ2V0cyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZV9vbl9zcGluKVxuICAgICAgICAgICAgICAgIHJldHVybiAkKCk7XG5cbiAgICAgICAgICAgIHZhciBmb3JtID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgIGlmIChmb3JtLmxlbmd0aCA+IDApICAvLyBEaXNhYmxlIGFsbCBmb3JtIGlucHV0cyBpZiBzcGlubmVyIGVsZW1lbnQgaXMgaW4gYSBmb3JtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0uZmluZCgnOmlucHV0Jyk7XG4gICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgLy8gb3IgYWxsIGlucHV0cyBjb250YWluZWQgaW4gdGhlIHNwaW5uZXIgZWxlbWVudCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5leHRlbmQoIHRoaXMuZWxlbWVudC5maW5kKCc6aW5wdXQnKSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2lkZ2V0IGluc3RhbmNlIChlLmcuIGVsZW1lbnQgY3JlYXRpb24sIGFwcGx5IHRoZW1pbmcsIGJpbmQgZXZlbnRzIGV0Yy4pXG4gICAgICAgIF9jcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBcHBlbmRpbmcnLCB3aWRnZXROYW1lLCAnaW5zdGFuY2UgdG8nLCB0aGlzLmVsZW1lbnQsICc6Jyk7XG4gICAgICAgICAgICB0aGlzLl9nZXREYXRhT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyID0gdGhpcy5fdGVtcGxhdGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuc3Bpbm5lcik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuc3Bpbm5lcik7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsX3RpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoJ3RpdGxlJykgfHwgXCJcIjtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0cyA9IHRoaXMuX2dldERpc2FibGVUYXJnZXRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVzdHJveSBwbHVnaW4gaW5zdGFuY2UgIGFuZCBjbGVhbiB1cCBtb2RpZmljYXRpb25zIHRoZSB3aWRnZXQgaGFzIG1hZGUgdG8gdGhlIERPTVxuICAgICAgICBfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0Rlc3Ryb3k6JywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIucmVtb3ZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHNwaW5uZXIgZnJvbSBpdHMgcmVsYXRpdmUgbG9jYXRpb25cbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKHJlbGF0aXZlX3Bvcykge1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyLmNzcyhyZWxhdGl2ZV9wb3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNob3csIEhpZGUsIGFuZCBUb2dnbGUgdGhlIHNwaW5uZXIuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLm9yaWdpbmFsX3RpdGxlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0cy5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCAnaGlkZGVuJyAsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLm9wdGlvbnMuc3Bpbl90ZXh0KTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0cy5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlciggJ3Nob3duJyAsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwaW5uZXIuaXMoXCI6dmlzaWJsZVwiKSkgdGhpcy5oaWRlKGV2ZW50KTsgZWxzZSB0aGlzLnNob3coZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9ycy5hcHBlbmQpLnNwaW5uZXIoKTtcblxufSkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApOyIsIi8qKlxuICogVG9nZ2xlIFRoYXQgKHYwLjEpOiB0b2dnbGVfdGhhdC5qc1xuICogICAtLSB0b2dnbGUgYSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgY29udHJvbHNcbiAqXG4gKiAgIERlcGVuZGVuY2llczogIEJvb3RzdHJhcCArIEpRdWVyeVxuICogICBNSVQgT3Blbi1zb3VyY2UgTGljZW5zZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bvd2RlcmZsYXNrL2Jvb3RzdHJhcF9leHRyYXMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldCcpO1xucmVxdWlyZSggJy4vanF1ZXJ5LXVpLXdpZGdldC1leHRlbnNpb25zJyk7XG5cbjsoZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuICAgIHZhciB3aWRnZXROYW1lID0gJ2JzZS50b2dnbGVfdGhhdCcsXG4gICAgICAgIHdpZGdldENsYXNzID0gJ2JzZS10b2dnbGUtdGhhdCcsXG4gICAgICAgIHNlbGVjdG9ycyA9IHdpZGdldENsYXNzLmJ1aWxkTmFtZXNNYXAoWydjb250cm9sJywgJ3RhcmdldCddLCAnLicpO1xuXG4gICAgJC53aWRnZXQoIHdpZGdldE5hbWUsIHtcblxuICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgaW5pdFRvZ2dsZTogdHJ1ZSwgICAvLyBmYWxzZSB0byBOT1QgdG9nZ2xlIGVsZW1lbnRzIGR1cmluZyBpbml0aWFsaXphdGlvblxuXG4gICAgICAgICAgICAvLyBldmVudCBjYWxsYmFja3MgKGFqYXggZXZlbnRzIGFkZGVkIGR1cmluZyBjcmVhdGUpXG4gICAgICAgICAgICB0b2dnbGVkOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXZlbnRzIGhhbmRsZWQgYnkgdGhpcyB3aWRnZXRcbiAgICAgICAgX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5jbGljayh0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdpZGdldCBpbnN0YW5jZSAoZS5nLiBlbGVtZW50IGNyZWF0aW9uLCBhcHBseSB0aGVtaW5nLCBiaW5kIGV2ZW50cyBldGMuKVxuICAgICAgICBfY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3JlYXRlICcsIHdpZGdldE5hbWUsICdpbnN0YW5jZSBmb3InLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sID0gdGhpcy5lbGVtZW50LmZpbmQoc2VsZWN0b3JzLmNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmVsZW1lbnQuZmluZChzZWxlY3RvcnMudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdFRvZ2dsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXN0cm95IHBsdWdpbiBpbnN0YW5jZSAgYW5kIGNsZWFuIHVwIG1vZGlmaWNhdGlvbnMgdGhlIHdpZGdldCBoYXMgbWFkZSB0byB0aGUgRE9NXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRGVzdHJveTonLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5vZmYoJ2NsaWNrJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUHVibGljIG1ldGhvZHNcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICB0aGlzLnRhcmdldC50b2dnbGUoKTtcbiAgICAgICAgICAgdGhpcy5fdHJpZ2dlciggJ3RvZ2dsZWQnICwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKHNlbGVjdG9yc1t3aWRnZXRDbGFzc10pLnRvZ2dsZV90aGF0KCk7XG5cbn0pKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTsiLCIvKipcbiAqIEJvb3RzdHJhcCBFeHRyYSBVdGlsaXRpZXNcbiAqICAgLi4uIG9yLCB0aGluZ3MgeW91IGNhbid0IGJlbGlldmUgYXJlIG5vdCBpbmNsdWRlZCBvdXQtb2YtdGhlLWJveCB3aXRoIEpTXG4gKlxuICogICBNSVQgT3Blbi1zb3VyY2UgTGljZW5zZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bvd2RlcmZsYXNrL2Jvb3RzdHJhcF9leHRyYXMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTgyMzQzMTcvMTk5MzUyNVxuU3RyaW5nLnByb3RvdHlwZS5mb3JtYXRVbmljb3JuID0gU3RyaW5nLnByb3RvdHlwZS5mb3JtYXRVbmljb3JuIHx8XG5mdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHN0ciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdCA9IHR5cGVvZiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciBhcmdzID0gKFwic3RyaW5nXCIgPT09IHQgfHwgXCJudW1iZXJcIiA9PT0gdCkgP1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFx7XCIgKyBrZXkgKyBcIlxcXFx9XCIsIFwiZ2lcIiksIGFyZ3Nba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuU3RyaW5nLnByb3RvdHlwZS5hc1RlbXBsYXRlID0gU3RyaW5nLnByb3RvdHlwZS5hc1RlbXBsYXRlIHx8XG5mdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmZvcm1hdFVuaWNvcm4oYXJncyk7XG4gICAgfTtcbn07XG5cbi8vIFJldHVybiBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0eSwgZWw6bmFtZSwgZm9yIGVhY2ggZWwgaW4gZXh0ZW5zaW9ucywgd2hlcmUgbmFtZSA9IHByZSArIHRoaXMgKyBzZXAgKyBlbFxuU3RyaW5nLnByb3RvdHlwZS5idWlsZE5hbWVzTWFwID0gU3RyaW5nLnByb3RvdHlwZS5idWlsZE5hbWVzTWFwIHx8XG5mdW5jdGlvbiAoZXh0ZW50aW9ucywgcHJlLCBzZXApIHtcbiAgcHJlID0gcHJlIHx8ICcnO1xuICBzZXAgPSBzZXAgfHwgJy0nO1xuICB2YXIgYmFzZSA9IHRoaXM7XG4gIGZ1bmN0aW9uIGJ1aWxkKG9iaiwga2V5KSB7XG4gICAgb2JqW2tleV0gPSBwcmUrYmFzZStzZXAra2V5O1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIG1hcCA9IGV4dGVudGlvbnMucmVkdWNlKGJ1aWxkLCB7fSk7XG4gIG1hcFtiYXNlXSA9IHByZStiYXNlO1xuICByZXR1cm4gbWFwO1xufTtcblxuXG4vLyByZXBsYWNlIGpRdWVyeS5hamF4IHdpdGggYSBmdW5jdGlvbiB0aGF0IG1vY2tzIGEgc3VjY2Vzc2Z1bCBBSkFYIHJlc3BvbnNlLlxuLy8gY2FsbCBic2VBamF4TW9ja1N1Y2Nlc3MoKSBiZWZvcmUgdGVzdGluZy4gIFRvIERvOiAgdXNlIHByb3BlciB0ZXN0aW5nIGZyYW1ld29yayAoamVzdCkgKyBodHRwOi8vc2lub25qcy5vcmcvI3Rlc3RpbmctYWpheFxuYnNlQWpheE1vY2tTdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgJC5hamF4ID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICBhcmdzLmJlZm9yZVNlbmQoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJjYWxsIGFqYXg6XCIsIGFyZ3MpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJncy5zdWNjZXNzKHttZXNzYWdlIDogJ01vY2sgQUpBWCBjYWxsIChzdWNjZXNzKS4nfSk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJncy5jb21wbGV0ZSgpO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICB9XG59OyJdfQ==
